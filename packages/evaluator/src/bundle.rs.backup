use paperclip_parser::ast::*;
use paperclip_parser::get_document_id;
use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use thiserror::Error;

/// File system abstraction for testing
pub trait FileSystem {
    /// Check if a file exists
    fn exists(&self, path: &Path) -> bool;

    /// Canonicalize a path (resolve symlinks, make absolute)
    fn canonicalize(&self, path: &Path) -> Result<PathBuf, std::io::Error>;
}

/// Real file system implementation
pub struct RealFileSystem;

impl FileSystem for RealFileSystem {
    fn exists(&self, path: &Path) -> bool {
        path.exists()
    }

    fn canonicalize(&self, path: &Path) -> Result<PathBuf, std::io::Error> {
        path.canonicalize()
    }
}

/// Mock file system for testing
pub struct MockFileSystem {
    pub existing_files: HashSet<PathBuf>,
}

impl MockFileSystem {
    pub fn new() -> Self {
        Self {
            existing_files: HashSet::new(),
        }
    }

    pub fn add_file(&mut self, path: PathBuf) {
        self.existing_files.insert(path);
    }
}

impl FileSystem for MockFileSystem {
    fn exists(&self, path: &Path) -> bool {
        self.existing_files.contains(path)
    }

    fn canonicalize(&self, path: &Path) -> Result<PathBuf, std::io::Error> {
        // For mock, just return the path as-is
        Ok(path.to_path_buf())
    }
}

#[derive(Error, Debug)]
pub enum BundleError {
    #[error("Circular dependency detected: {path}")]
    CircularDependency { path: String },

    #[error("Import not found: {import_path} imported by {source_path}")]
    ImportNotFound {
        import_path: String,
        source_path: String,
    },

    #[error("Style '{name}' not found in bundle")]
    StyleNotFound { name: String },

    #[error("Token '{name}' not found in bundle")]
    TokenNotFound { name: String },

    #[error("Component '{name}' not found in bundle")]
    ComponentNotFound { name: String },
}

/// Asset reference extracted from AST
#[derive(Clone, Debug)]
pub struct AssetReference {
    pub path: String,
    pub asset_type: AssetType,
    pub resolved_path: PathBuf,
    pub source_file: PathBuf,
}

#[derive(Clone, Debug, PartialEq)]
pub enum AssetType {
    Image,
    Font,
    Video,
    Audio,
    Other,
}

/// Bundle - collection of parsed documents with dependency graph
#[derive(Clone, Debug)]
pub struct Bundle {
    /// All parsed documents (path -> AST)
    documents: HashMap<PathBuf, Document>,

    /// Dependency graph: file -> files it imports
    dependencies: HashMap<PathBuf, Vec<PathBuf>>,

    /// Reverse lookup: file -> files that import it
    dependents: HashMap<PathBuf, Vec<PathBuf>>,

    /// Import alias mapping: (source_file, alias) -> resolved_path
    /// Enables efficient lookup of "theme.fontRegular" style references
    import_aliases: HashMap<(PathBuf, String), PathBuf>,

    /// Deduplicated assets with source file tracking
    /// Maps asset path -> (AssetReference, Set of source files that use it)
    assets: HashMap<String, (AssetReference, HashSet<PathBuf>)>,

    /// Document IDs for each file (CRC32 of file path)
    document_ids: HashMap<PathBuf, String>,
}

impl Bundle {
    /// Create an empty bundle
    pub fn new() -> Self {
        Self {
            documents: HashMap::new(),
            dependencies: HashMap::new(),
            dependents: HashMap::new(),
            import_aliases: HashMap::new(),
            assets: HashMap::new(),
            document_ids: HashMap::new(),
        }
    }

    /// Add a document to the bundle
    pub fn add_document(&mut self, path: PathBuf, document: Document) {
        let document_id = get_document_id(&path.to_string_lossy());
        self.document_ids.insert(path.clone(), document_id);
        self.documents.insert(path, document);
    }

    /// Build dependency graph from import statements
    pub fn build_dependencies(&mut self, project_root: &Path) -> Result<(), BundleError> {
        self.build_dependencies_with_fs(project_root, &RealFileSystem)
    }

    /// Build dependency graph asynchronously (requires 'async' feature)
    #[cfg(feature = "async")]
    pub async fn build_dependencies_async(
        &mut self,
        project_root: PathBuf,
    ) -> Result<(), BundleError> {
        self.build_dependencies_with_fs_async(project_root, RealFileSystem)
            .await
    }

    /// Build dependency graph asynchronously with custom file system (requires 'async' feature)
    #[cfg(feature = "async")]
    pub async fn build_dependencies_with_fs_async<F: FileSystem + Send + 'static>(
        &mut self,
        project_root: PathBuf,
        fs: F,
    ) -> Result<(), BundleError> {
        // Clone necessary data for the blocking task
        let documents = self.documents.clone();

        // Run the dependency building in a blocking task
        let result = tokio::task::spawn_blocking(move || {
            let mut temp_bundle = Bundle::new();
            temp_bundle.documents = documents;
            temp_bundle.build_dependencies_with_fs(&project_root, &fs)?;
            Ok::<_, BundleError>((
                temp_bundle.dependencies,
                temp_bundle.dependents,
                temp_bundle.import_aliases,
            ))
        })
        .await
        .map_err(|e| BundleError::ImportNotFound {
            import_path: "spawn_blocking failed".to_string(),
            source_path: e.to_string(),
        })??;

        // Update self with the computed data
        self.dependencies = result.0;
        self.dependents = result.1;
        self.import_aliases = result.2;

        Ok(())
    }

    /// Build dependency graph with custom file system (for testing)
    pub fn build_dependencies_with_fs(
        &mut self,
        project_root: &Path,
        fs: &dyn FileSystem,
    ) -> Result<(), BundleError> {
        let mut dependencies = HashMap::new();
        let mut dependents: HashMap<PathBuf, Vec<PathBuf>> = HashMap::new();
        let mut import_aliases = HashMap::new();

        for (file_path, document) in &self.documents {
            let mut file_deps = Vec::new();

            for import in &document.imports {
                // Resolve import path relative to current file
                let import_resolved =
                    self.resolve_import_path(&import.path, file_path, project_root, fs)?;

                file_deps.push(import_resolved.clone());

                // Store alias mapping if import has an alias
                if let Some(ref alias) = import.alias {
                    import_aliases
                        .insert((file_path.clone(), alias.clone()), import_resolved.clone());
                }

                // Add to dependents (reverse lookup)
                dependents
                    .entry(import_resolved)
                    .or_insert_with(Vec::new)
                    .push(file_path.clone());
            }

            dependencies.insert(file_path.clone(), file_deps);
        }

        self.dependencies = dependencies;
        self.dependents = dependents;
        self.import_aliases = import_aliases;

        // Check for circular dependencies
        self.detect_circular_dependencies()?;

        Ok(())
    }

    /// Resolve import path relative to importing file
    fn resolve_import_path(
        &self,
        import_path: &str,
        importing_file: &Path,
        project_root: &Path,
        fs: &dyn FileSystem,
    ) -> Result<PathBuf, BundleError> {
        // Resolve the import path
        let resolved = if import_path.starts_with("./") || import_path.starts_with("../") {
            // Relative import - resolve from importing file's directory
            importing_file
                .parent()
                .unwrap_or(project_root)
                .join(import_path)
        } else {
            // Absolute from project root
            project_root.join(import_path)
        };

        // Strategy: Try multiple path representations to handle temp dirs, relative paths, etc.

        // 1. Try the resolved path as-is
        if self.documents.contains_key(&resolved) {
            return Ok(resolved);
        }

        // 2. Try canonicalizing (handles symlinks, makes absolute)
        if let Ok(canonicalized) = fs.canonicalize(&resolved) {
            if self.documents.contains_key(&canonicalized) {
                return Ok(canonicalized);
            }
        }

        // 3. Try normalizing the path (remove ./ and ../ segments)
        let normalized = self.normalize_path(&resolved);
        if self.documents.contains_key(&normalized) {
            return Ok(normalized);
        }

        // 4. Search by matching the resolved path against existing document paths
        // This handles cases where paths are stored differently (absolute vs relative)
        for existing_path in self.documents.keys() {
            if self.paths_match(&resolved, existing_path) {
                return Ok(existing_path.clone());
            }
        }

        Err(BundleError::ImportNotFound {
            import_path: import_path.to_string(),
            source_path: importing_file.display().to_string(),
        })
    }

    /// Normalize a path by removing ./ and resolving ../
    fn normalize_path(&self, path: &Path) -> PathBuf {
        let mut components = Vec::new();
        for component in path.components() {
            match component {
                std::path::Component::CurDir => {
                    // Skip "./"
                }
                std::path::Component::ParentDir => {
                    // Pop the last component for "../"
                    components.pop();
                }
                _ => {
                    components.push(component);
                }
            }
        }
        components.iter().collect()
    }

    /// Check if two paths refer to the same file
    fn paths_match(&self, path1: &Path, path2: &Path) -> bool {
        // Exact match
        if path1 == path2 {
            return true;
        }

        // Match by normalized paths
        let norm1 = self.normalize_path(path1);
        let norm2 = self.normalize_path(path2);
        if norm1 == norm2 {
            return true;
        }

        // Match if one path ends with the other (handles absolute vs relative)
        if let (Some(file1), Some(file2)) = (path1.file_name(), path2.file_name()) {
            if file1 == file2 {
                // Same filename, check if parent directories align
                if let (Some(parent1), Some(parent2)) = (path1.parent(), path2.parent()) {
                    // Recursively check parents
                    return self.paths_match(parent1, parent2);
                }
                // One has no parent - could be just a filename
                return true;
            }
        }

        false
    }

    /// Detect circular dependencies using DFS
    fn detect_circular_dependencies(&self) -> Result<(), BundleError> {
        let mut visited = HashSet::new();
        let mut rec_stack = HashSet::new();

        for file_path in self.documents.keys() {
            if !visited.contains(file_path) {
                self.detect_cycle_dfs(file_path, &mut visited, &mut rec_stack)?;
            }
        }

        Ok(())
    }

    fn detect_cycle_dfs(
        &self,
        node: &PathBuf,
        visited: &mut HashSet<PathBuf>,
        rec_stack: &mut HashSet<PathBuf>,
    ) -> Result<(), BundleError> {
        visited.insert(node.clone());
        rec_stack.insert(node.clone());

        if let Some(deps) = self.dependencies.get(node) {
            for dep in deps {
                if !visited.contains(dep) {
                    self.detect_cycle_dfs(dep, visited, rec_stack)?;
                } else if rec_stack.contains(dep) {
                    return Err(BundleError::CircularDependency {
                        path: dep.display().to_string(),
                    });
                }
            }
        }

        rec_stack.remove(node);
        Ok(())
    }

    /// Get document by path
    pub fn get_document(&self, path: &Path) -> Option<&Document> {
        self.documents.get(path)
    }

    /// Get document ID for a file
    pub fn get_document_id(&self, path: &Path) -> Option<&str> {
        self.document_ids.get(path).map(|s| s.as_str())
    }

    /// Get all documents
    pub fn documents(&self) -> &HashMap<PathBuf, Document> {
        &self.documents
    }

    /// Get dependencies for a file
    pub fn get_dependencies(&self, path: &Path) -> Option<&[PathBuf]> {
        self.dependencies.get(path).map(|v| v.as_slice())
    }

    /// Get dependents (files that import this file)
    pub fn get_dependents(&self, path: &Path) -> Option<&[PathBuf]> {
        self.dependents.get(path).map(|v| v.as_slice())
    }

    /// Add asset reference
    /// Add an asset reference, deduplicating by path
    /// If the asset already exists, adds the source file to its users set
    pub fn add_asset(&mut self, asset: AssetReference) {
        self.assets
            .entry(asset.path.clone())
            .and_modify(|(_, sources)| {
                sources.insert(asset.source_file.clone());
            })
            .or_insert_with(|| {
                let mut sources = HashSet::new();
                sources.insert(asset.source_file.clone());
                (asset, sources)
            });
    }

    /// Get all unique assets (iterator)
    pub fn unique_assets(&self) -> impl Iterator<Item = &AssetReference> {
        self.assets.values().map(|(asset, _)| asset)
    }

    /// Get all source files that use a specific asset
    pub fn asset_users(&self, asset_path: &str) -> Option<&HashSet<PathBuf>> {
        self.assets.get(asset_path).map(|(_, sources)| sources)
    }

    /// Get all assets used by a specific source file
    pub fn assets_for_file(&self, file: &Path) -> Vec<&AssetReference> {
        self.assets
            .values()
            .filter(|(_, sources)| sources.contains(file))
            .map(|(asset, _)| asset)
            .collect()
    }

    /// Get total count of unique assets
    pub fn unique_asset_count(&self) -> usize {
        self.assets.len()
    }

    /// Deprecated: Use unique_assets() instead
    /// Returns a Vec for backwards compatibility
    #[deprecated(since = "0.2.0", note = "Use unique_assets() for better performance")]
    pub fn assets(&self) -> Vec<&AssetReference> {
        self.unique_assets().collect()
    }

    /// Look up a style declaration by name across the bundle
    /// Supports namespaced references like "theme.fontRegular"
    /// Searches in the given file and its imports
    pub fn find_style(
        &self,
        style_ref: &str,
        current_file: &Path,
    ) -> Option<(&StyleDecl, PathBuf)> {
        // Check if this is a namespaced reference (e.g., "theme.fontRegular")
        if let Some((namespace, style_name)) = style_ref.split_once('.') {
            // Look up the resolved path using the import alias
            let key = (current_file.to_path_buf(), namespace.to_string());
            if let Some(imported_file) = self.import_aliases.get(&key) {
                // Look in the specific imported file
                if let Some(dep_doc) = self.documents.get(imported_file) {
                    if let Some(style) = dep_doc
                        .styles
                        .iter()
                        .find(|s| s.name == style_name && s.public)
                    {
                        return Some((style, imported_file.clone()));
                    }
                }
            }
            return None;
        }

        // Not namespaced - check current file only
        if let Some(doc) = self.documents.get(current_file) {
            if let Some(style) = doc.styles.iter().find(|s| s.name == style_ref) {
                return Some((style, current_file.to_path_buf()));
            }
        }

        None
    }

    /// Look up a token by name across the bundle
    /// Supports namespaced references like "theme.primaryColor"
    pub fn find_token(
        &self,
        token_ref: &str,
        current_file: &Path,
    ) -> Option<(&TokenDecl, PathBuf)> {
        // Check if this is a namespaced reference (e.g., "theme.primaryColor")
        if let Some((namespace, token_name)) = token_ref.split_once('.') {
            // Look up the resolved path using the import alias
            let key = (current_file.to_path_buf(), namespace.to_string());
            if let Some(imported_file) = self.import_aliases.get(&key) {
                // Look in the specific imported file
                if let Some(dep_doc) = self.documents.get(imported_file) {
                    if let Some(token) = dep_doc
                        .tokens
                        .iter()
                        .find(|t| t.name == token_name && t.public)
                    {
                        return Some((token, imported_file.clone()));
                    }
                }
            }
            return None;
        }

        // Not namespaced - check current file only
        if let Some(doc) = self.documents.get(current_file) {
            if let Some(token) = doc.tokens.iter().find(|t| t.name == token_ref) {
                return Some((token, current_file.to_path_buf()));
            }
        }

        None
    }

    /// Look up a component by name across the bundle
    /// Supports namespaced references like "theme.Button"
    pub fn find_component(
        &self,
        component_ref: &str,
        current_file: &Path,
    ) -> Option<(&Component, PathBuf)> {
        // Check if this is a namespaced reference (e.g., "theme.Button")
        if let Some((namespace, component_name)) = component_ref.split_once('.') {
            // Look up the resolved path using the import alias
            let key = (current_file.to_path_buf(), namespace.to_string());
            if let Some(imported_file) = self.import_aliases.get(&key) {
                // Look in the specific imported file
                if let Some(dep_doc) = self.documents.get(imported_file) {
                    if let Some(component) = dep_doc
                        .components
                        .iter()
                        .find(|c| c.name == component_name && c.public)
                    {
                        return Some((component, imported_file.clone()));
                    }
                }
            }
            return None;
        }

        // Not namespaced - check current file only
        if let Some(doc) = self.documents.get(current_file) {
            if let Some(component) = doc.components.iter().find(|c| c.name == component_ref) {
                return Some((component, current_file.to_path_buf()));
            }
        }

        None
    }
}

impl Default for Bundle {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use paperclip_parser::parse_with_path;

    #[test]
    fn test_bundle_creation() {
        let mut bundle = Bundle::new();

        let source = r#"
            public style Button {
                padding: 8px
            }
        "#;

        let doc = parse_with_path(source, "/test.pc").unwrap();
        bundle.add_document(PathBuf::from("/test.pc"), doc);

        assert_eq!(bundle.documents().len(), 1);
        assert!(bundle.get_document(Path::new("/test.pc")).is_some());
    }

    #[test]
    fn test_dependency_graph() {
        let mut bundle = Bundle::new();

        // Create base styles file
        let base_source = r#"
            public style BaseButton {
                padding: 8px
            }
        "#;
        let base_doc = parse_with_path(base_source, "/styles/base.pc").unwrap();
        bundle.add_document(PathBuf::from("/styles/base.pc"), base_doc);

        // Create main file that imports base
        let main_source = r#"
            import "./styles/base.pc"

            public component Button {
                render button {}
            }
        "#;
        let main_doc = parse_with_path(main_source, "/main.pc").unwrap();
        bundle.add_document(PathBuf::from("/main.pc"), main_doc);

        // Note: build_dependencies needs project_root, which we can't easily test here
        // This test verifies structure creation
        assert_eq!(bundle.documents().len(), 2);
    }

    #[test]
    fn test_find_style_in_bundle() {
        let mut bundle = Bundle::new();

        let source = r#"
            public style ButtonStyle {
                padding: 8px
            }
        "#;

        let doc = parse_with_path(source, "/test.pc").unwrap();
        let path = PathBuf::from("/test.pc");
        bundle.add_document(path.clone(), doc);

        let result = bundle.find_style("ButtonStyle", &path);
        assert!(result.is_some());

        let (style, found_path) = result.unwrap();
        assert_eq!(style.name, "ButtonStyle");
        assert_eq!(found_path, path);
    }

    #[test]
    fn test_document_id_tracking() {
        let mut bundle = Bundle::new();

        let source = r#"
            public component Test {
                render div {}
            }
        "#;

        let doc = parse_with_path(source, "/test.pc").unwrap();
        let path = PathBuf::from("/test.pc");
        bundle.add_document(path.clone(), doc);

        let doc_id = bundle.get_document_id(&path);
        assert!(doc_id.is_some());
        assert!(!doc_id.unwrap().is_empty());
    }
}
