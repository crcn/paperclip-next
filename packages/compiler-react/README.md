# Paperclip React Compiler

Compiles Paperclip `.pc` files to React components.

## Overview

This package takes the AST generated by `paperclip-parser` and transforms it into production-ready React code (JavaScript/JSX).

## Features

- ✅ Component compilation with `React.memo` and `forwardRef`
- ✅ Props and children support
- ✅ Conditional rendering (`if/else`)
- ✅ List rendering (`repeat`)
- ✅ Variants (component states)
- ✅ Slots (content insertion points)
- ✅ Design tokens export
- ✅ Style mixins export
- ✅ Nested components
- ✅ Attribute conversion (e.g., `class` → `className`)
- ✅ **TypeScript definition generation (.d.ts files)**
- ✅ **Type inference for component props**
- ⬜ CSS module integration (coming soon)

## Usage

```rust
use paperclip_parser::parse;
use paperclip_compiler_react::{compile_to_react, CompileOptions};

fn main() {
    let source = r#"
        public component Button {
            render button {
                style {
                    padding: 8px 16px
                    background: #3366FF
                    color: white
                }
                text "Click me"
            }
        }
    "#;

    let document = parse(source).expect("Failed to parse");
    let options = CompileOptions::default();
    let react_code = compile_to_react(&document, options).expect("Failed to compile");

    println!("{}", react_code);
}
```

## Example Output

Input (`.pc`):
```javascript
public component Button {
    render button {
        text "Click me"
    }
}
```

Output (`.jsx`):
```javascript
import "./styles.css";
import React from "react";

// Utility function to merge class names
const cx = (...classes) => classes.filter(Boolean).join(" ");

const _Button = (props, ref) => {
  return (
    <button ref={ref}>Click me</button>
  );
};
_Button.displayName = "Button";
const Button = React.memo(React.forwardRef(_Button));
export { Button };
```

### TypeScript Definitions

With type inference, generate TypeScript definitions:

```rust
let document = parse(source)?;
let defs = compile_definitions(&document, options)?;
```

Output (`.d.ts`):
```typescript
import React from "react";

export interface ButtonProps {
  ref?: React.Ref<any>;
}

export const Button: React.FC<ButtonProps>;
```

For components with props, variants, and slots:

```javascript
public component Card {
    variant highlighted
    slot header

    render div {
        text {title}
        text {description}
        header
    }
}
```

Generates:
```typescript
export interface CardProps {
  ref?: React.Ref<any>;
  description: any;
  header: React.ReactNode;
  highlighted?: boolean;
  title: any;
}

export const Card: React.FC<CardProps>;
```

## API

### `compile_to_react(document: &Document, options: CompileOptions) -> Result<String, String>`

Compiles a Paperclip document AST to React code.

**Parameters:**
- `document`: The parsed Paperclip AST
- `options`: Compilation options

**Returns:**
- `Ok(String)`: The generated React code
- `Err(String)`: Compilation error message

### `compile_definitions(document: &Document, options: CompileOptions) -> Result<String, String>`

Generates TypeScript definition file (.d.ts) for a Paperclip document.

**Parameters:**
- `document`: The parsed Paperclip AST
- `options`: Compilation options

**Returns:**
- `Ok(String)`: The generated TypeScript definitions
- `Err(String)`: Compilation error message

**Example:**
```rust
let document = parse(source)?;
let defs = compile_definitions(&document, CompileOptions::default())?;
std::fs::write("components.d.ts", defs)?;
```

### `infer_component_props(component: &Component) -> BTreeMap<String, PropertyType>`

Infers TypeScript prop types from a component's AST.

**Returns:** A map of prop names to their inferred types

### `CompileOptions`

Configuration options for the React compiler.

```rust
pub struct CompileOptions {
    /// Whether to use TypeScript types (default: false)
    pub use_typescript: bool,

    /// Whether to include CSS imports (default: true)
    pub include_css_imports: bool,
}
```

## Architecture

The compiler follows a visitor pattern to traverse the AST:

1. **Imports Phase**: Generate React and CSS imports
2. **Utilities Phase**: Add helper functions (e.g., `cx` for className merging)
3. **Components Phase**: Compile each component to React code
4. **Exports Phase**: Export public tokens and styles

### Component Compilation

Each component is transformed into:
1. An inner function `_ComponentName(props, ref)` with the render logic
2. A wrapped version using `React.memo(React.forwardRef(_ComponentName))`
3. An export statement if the component is public

### Expression Compilation

Paperclip expressions are converted to JavaScript:
- `{variable}` → `{props.variable}`
- `{obj.prop}` → `{props.obj.prop}`
- `{a + b}` → `{(props.a + props.b)}`

### Element Compilation

Elements are compiled based on their type:
- **Tag**: HTML elements → JSX elements with props
- **Text**: Text nodes with expression interpolation
- **Instance**: Component instances → React component usage
- **Conditional**: `if/else` → Ternary expressions
- **Repeat**: `repeat item in collection` → `.map()` calls
- **SlotInsert**: Slot insertion → Direct prop access

## Testing

Run the test suite:

```bash
cargo test --package paperclip-compiler-react
```

## Integration with Paperclip Workflow

```
┌─────────────┐
│  .pc file   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   Parser    │  (paperclip-parser)
└──────┬──────┘
       │
       ▼
┌─────────────┐
│     AST     │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│   React     │  (paperclip-compiler-react)
│  Compiler   │
└──────┬──────┘
       │
       ▼
┌─────────────┐
│  .jsx file  │
└─────────────┘
```

## Future Enhancements

- [ ] TypeScript `.d.ts` file generation
- [ ] CSS Modules integration
- [ ] Source maps for debugging
- [ ] Optimization passes (dead code elimination, etc.)
- [ ] Custom render functions support
- [ ] Server-side rendering (SSR) optimizations
- [ ] React Native output target
