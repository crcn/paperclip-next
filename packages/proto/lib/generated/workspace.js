// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: workspace.proto
/* eslint-disable */
import Long from "long";
import * as _m0 from "protobufjs/minimal";
import { VDocPatch } from "./patches";
export const protobufPackage = "paperclip.workspace";
/** Node type enum */
export var NodeType;
(function (NodeType) {
    NodeType[NodeType["COMPONENT"] = 0] = "COMPONENT";
    NodeType[NodeType["ELEMENT"] = 1] = "ELEMENT";
    NodeType[NodeType["TEXT"] = 2] = "TEXT";
    NodeType[NodeType["CONDITIONAL"] = 3] = "CONDITIONAL";
    NodeType[NodeType["REPEAT"] = 4] = "REPEAT";
    NodeType[NodeType["INSERT"] = 5] = "INSERT";
    NodeType[NodeType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NodeType || (NodeType = {}));
export function nodeTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "COMPONENT":
            return NodeType.COMPONENT;
        case 1:
        case "ELEMENT":
            return NodeType.ELEMENT;
        case 2:
        case "TEXT":
            return NodeType.TEXT;
        case 3:
        case "CONDITIONAL":
            return NodeType.CONDITIONAL;
        case 4:
        case "REPEAT":
            return NodeType.REPEAT;
        case 5:
        case "INSERT":
            return NodeType.INSERT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return NodeType.UNRECOGNIZED;
    }
}
export function nodeTypeToJSON(object) {
    switch (object) {
        case NodeType.COMPONENT:
            return "COMPONENT";
        case NodeType.ELEMENT:
            return "ELEMENT";
        case NodeType.TEXT:
            return "TEXT";
        case NodeType.CONDITIONAL:
            return "CONDITIONAL";
        case NodeType.REPEAT:
            return "REPEAT";
        case NodeType.INSERT:
            return "INSERT";
        case NodeType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var FileEvent_EventType;
(function (FileEvent_EventType) {
    FileEvent_EventType[FileEvent_EventType["CREATED"] = 0] = "CREATED";
    FileEvent_EventType[FileEvent_EventType["MODIFIED"] = 1] = "MODIFIED";
    FileEvent_EventType[FileEvent_EventType["DELETED"] = 2] = "DELETED";
    FileEvent_EventType[FileEvent_EventType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FileEvent_EventType || (FileEvent_EventType = {}));
export function fileEvent_EventTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "CREATED":
            return FileEvent_EventType.CREATED;
        case 1:
        case "MODIFIED":
            return FileEvent_EventType.MODIFIED;
        case 2:
        case "DELETED":
            return FileEvent_EventType.DELETED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return FileEvent_EventType.UNRECOGNIZED;
    }
}
export function fileEvent_EventTypeToJSON(object) {
    switch (object) {
        case FileEvent_EventType.CREATED:
            return "CREATED";
        case FileEvent_EventType.MODIFIED:
            return "MODIFIED";
        case FileEvent_EventType.DELETED:
            return "DELETED";
        case FileEvent_EventType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePreviewRequest() {
    return { rootPath: "" };
}
export const PreviewRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.rootPath !== "") {
            writer.uint32(10).string(message.rootPath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreviewRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rootPath = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { rootPath: isSet(object.rootPath) ? globalThis.String(object.rootPath) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.rootPath !== "") {
            obj.rootPath = message.rootPath;
        }
        return obj;
    },
    create(base) {
        return PreviewRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreviewRequest();
        message.rootPath = object.rootPath ?? "";
        return message;
    },
};
function createBasePreviewUpdate() {
    return {
        filePath: "",
        patches: [],
        error: undefined,
        timestamp: 0,
        version: 0,
        acknowledgedMutationIds: [],
        changedByClientId: undefined,
    };
}
export const PreviewUpdate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.filePath !== "") {
            writer.uint32(10).string(message.filePath);
        }
        for (const v of message.patches) {
            VDocPatch.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.error !== undefined) {
            writer.uint32(26).string(message.error);
        }
        if (message.timestamp !== 0) {
            writer.uint32(32).int64(message.timestamp);
        }
        if (message.version !== 0) {
            writer.uint32(40).uint64(message.version);
        }
        for (const v of message.acknowledgedMutationIds) {
            writer.uint32(50).string(v);
        }
        if (message.changedByClientId !== undefined) {
            writer.uint32(58).string(message.changedByClientId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreviewUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.patches.push(VDocPatch.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.int64());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.version = longToNumber(reader.uint64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.acknowledgedMutationIds.push(reader.string());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.changedByClientId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e) => VDocPatch.fromJSON(e)) : [],
            error: isSet(object.error) ? globalThis.String(object.error) : undefined,
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
            acknowledgedMutationIds: globalThis.Array.isArray(object?.acknowledgedMutationIds)
                ? object.acknowledgedMutationIds.map((e) => globalThis.String(e))
                : [],
            changedByClientId: isSet(object.changedByClientId) ? globalThis.String(object.changedByClientId) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.patches?.length) {
            obj.patches = message.patches.map((e) => VDocPatch.toJSON(e));
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        if (message.acknowledgedMutationIds?.length) {
            obj.acknowledgedMutationIds = message.acknowledgedMutationIds;
        }
        if (message.changedByClientId !== undefined) {
            obj.changedByClientId = message.changedByClientId;
        }
        return obj;
    },
    create(base) {
        return PreviewUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreviewUpdate();
        message.filePath = object.filePath ?? "";
        message.patches = object.patches?.map((e) => VDocPatch.fromPartial(e)) || [];
        message.error = object.error ?? undefined;
        message.timestamp = object.timestamp ?? 0;
        message.version = object.version ?? 0;
        message.acknowledgedMutationIds = object.acknowledgedMutationIds?.map((e) => e) || [];
        message.changedByClientId = object.changedByClientId ?? undefined;
        return message;
    },
};
function createBaseWatchRequest() {
    return { directory: "", patterns: [] };
}
export const WatchRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.directory !== "") {
            writer.uint32(10).string(message.directory);
        }
        for (const v of message.patterns) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWatchRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.directory = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.patterns.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            directory: isSet(object.directory) ? globalThis.String(object.directory) : "",
            patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e) => globalThis.String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.directory !== "") {
            obj.directory = message.directory;
        }
        if (message.patterns?.length) {
            obj.patterns = message.patterns;
        }
        return obj;
    },
    create(base) {
        return WatchRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWatchRequest();
        message.directory = object.directory ?? "";
        message.patterns = object.patterns?.map((e) => e) || [];
        return message;
    },
};
function createBaseFileEvent() {
    return { eventType: 0, filePath: "", timestamp: 0 };
}
export const FileEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.eventType !== 0) {
            writer.uint32(8).int32(message.eventType);
        }
        if (message.filePath !== "") {
            writer.uint32(18).string(message.filePath);
        }
        if (message.timestamp !== 0) {
            writer.uint32(24).int64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.eventType = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            eventType: isSet(object.eventType) ? fileEvent_EventTypeFromJSON(object.eventType) : 0,
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.eventType !== 0) {
            obj.eventType = fileEvent_EventTypeToJSON(message.eventType);
        }
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        return obj;
    },
    create(base) {
        return FileEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFileEvent();
        message.eventType = object.eventType ?? 0;
        message.filePath = object.filePath ?? "";
        message.timestamp = object.timestamp ?? 0;
        return message;
    },
};
function createBaseMutationRequest() {
    return { clientId: "", filePath: "", mutation: undefined, expectedVersion: 0 };
}
export const MutationRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.filePath !== "") {
            writer.uint32(18).string(message.filePath);
        }
        if (message.mutation !== undefined) {
            Mutation.encode(message.mutation, writer.uint32(26).fork()).ldelim();
        }
        if (message.expectedVersion !== 0) {
            writer.uint32(32).uint64(message.expectedVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.mutation = Mutation.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.expectedVersion = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            mutation: isSet(object.mutation) ? Mutation.fromJSON(object.mutation) : undefined,
            expectedVersion: isSet(object.expectedVersion) ? globalThis.Number(object.expectedVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.mutation !== undefined) {
            obj.mutation = Mutation.toJSON(message.mutation);
        }
        if (message.expectedVersion !== 0) {
            obj.expectedVersion = Math.round(message.expectedVersion);
        }
        return obj;
    },
    create(base) {
        return MutationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutationRequest();
        message.clientId = object.clientId ?? "";
        message.filePath = object.filePath ?? "";
        message.mutation = (object.mutation !== undefined && object.mutation !== null)
            ? Mutation.fromPartial(object.mutation)
            : undefined;
        message.expectedVersion = object.expectedVersion ?? 0;
        return message;
    },
};
function createBaseMutationResponse() {
    return { ack: undefined, rebased: undefined, noop: undefined };
}
export const MutationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ack !== undefined) {
            MutationAck.encode(message.ack, writer.uint32(10).fork()).ldelim();
        }
        if (message.rebased !== undefined) {
            MutationRebased.encode(message.rebased, writer.uint32(18).fork()).ldelim();
        }
        if (message.noop !== undefined) {
            MutationNoop.encode(message.noop, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.ack = MutationAck.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.rebased = MutationRebased.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.noop = MutationNoop.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ack: isSet(object.ack) ? MutationAck.fromJSON(object.ack) : undefined,
            rebased: isSet(object.rebased) ? MutationRebased.fromJSON(object.rebased) : undefined,
            noop: isSet(object.noop) ? MutationNoop.fromJSON(object.noop) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ack !== undefined) {
            obj.ack = MutationAck.toJSON(message.ack);
        }
        if (message.rebased !== undefined) {
            obj.rebased = MutationRebased.toJSON(message.rebased);
        }
        if (message.noop !== undefined) {
            obj.noop = MutationNoop.toJSON(message.noop);
        }
        return obj;
    },
    create(base) {
        return MutationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutationResponse();
        message.ack = (object.ack !== undefined && object.ack !== null) ? MutationAck.fromPartial(object.ack) : undefined;
        message.rebased = (object.rebased !== undefined && object.rebased !== null)
            ? MutationRebased.fromPartial(object.rebased)
            : undefined;
        message.noop = (object.noop !== undefined && object.noop !== null)
            ? MutationNoop.fromPartial(object.noop)
            : undefined;
        return message;
    },
};
function createBaseMutationAck() {
    return { mutationId: "", newVersion: 0, timestamp: 0 };
}
export const MutationAck = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.mutationId !== "") {
            writer.uint32(10).string(message.mutationId);
        }
        if (message.newVersion !== 0) {
            writer.uint32(16).uint64(message.newVersion);
        }
        if (message.timestamp !== 0) {
            writer.uint32(24).int64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutationAck();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mutationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.newVersion = longToNumber(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
            newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mutationId !== "") {
            obj.mutationId = message.mutationId;
        }
        if (message.newVersion !== 0) {
            obj.newVersion = Math.round(message.newVersion);
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        return obj;
    },
    create(base) {
        return MutationAck.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutationAck();
        message.mutationId = object.mutationId ?? "";
        message.newVersion = object.newVersion ?? 0;
        message.timestamp = object.timestamp ?? 0;
        return message;
    },
};
function createBaseMutationRebased() {
    return { originalMutationId: "", transformedMutation: undefined, newVersion: 0, reason: "" };
}
export const MutationRebased = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.originalMutationId !== "") {
            writer.uint32(10).string(message.originalMutationId);
        }
        if (message.transformedMutation !== undefined) {
            Mutation.encode(message.transformedMutation, writer.uint32(18).fork()).ldelim();
        }
        if (message.newVersion !== 0) {
            writer.uint32(24).uint64(message.newVersion);
        }
        if (message.reason !== "") {
            writer.uint32(34).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutationRebased();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.originalMutationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.transformedMutation = Mutation.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.newVersion = longToNumber(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.reason = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            originalMutationId: isSet(object.originalMutationId) ? globalThis.String(object.originalMutationId) : "",
            transformedMutation: isSet(object.transformedMutation)
                ? Mutation.fromJSON(object.transformedMutation)
                : undefined,
            newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
            reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.originalMutationId !== "") {
            obj.originalMutationId = message.originalMutationId;
        }
        if (message.transformedMutation !== undefined) {
            obj.transformedMutation = Mutation.toJSON(message.transformedMutation);
        }
        if (message.newVersion !== 0) {
            obj.newVersion = Math.round(message.newVersion);
        }
        if (message.reason !== "") {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return MutationRebased.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutationRebased();
        message.originalMutationId = object.originalMutationId ?? "";
        message.transformedMutation = (object.transformedMutation !== undefined && object.transformedMutation !== null)
            ? Mutation.fromPartial(object.transformedMutation)
            : undefined;
        message.newVersion = object.newVersion ?? 0;
        message.reason = object.reason ?? "";
        return message;
    },
};
function createBaseMutationNoop() {
    return { mutationId: "", reason: "" };
}
export const MutationNoop = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.mutationId !== "") {
            writer.uint32(10).string(message.mutationId);
        }
        if (message.reason !== "") {
            writer.uint32(18).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutationNoop();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mutationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reason = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
            reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mutationId !== "") {
            obj.mutationId = message.mutationId;
        }
        if (message.reason !== "") {
            obj.reason = message.reason;
        }
        return obj;
    },
    create(base) {
        return MutationNoop.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutationNoop();
        message.mutationId = object.mutationId ?? "";
        message.reason = object.reason ?? "";
        return message;
    },
};
function createBaseMutation() {
    return {
        mutationId: "",
        timestamp: 0,
        moveElement: undefined,
        updateText: undefined,
        setInlineStyle: undefined,
        setAttribute: undefined,
        removeNode: undefined,
        insertElement: undefined,
        setFrameBounds: undefined,
    };
}
export const Mutation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.mutationId !== "") {
            writer.uint32(10).string(message.mutationId);
        }
        if (message.timestamp !== 0) {
            writer.uint32(16).int64(message.timestamp);
        }
        if (message.moveElement !== undefined) {
            MoveElement.encode(message.moveElement, writer.uint32(26).fork()).ldelim();
        }
        if (message.updateText !== undefined) {
            UpdateText.encode(message.updateText, writer.uint32(34).fork()).ldelim();
        }
        if (message.setInlineStyle !== undefined) {
            SetInlineStyle.encode(message.setInlineStyle, writer.uint32(42).fork()).ldelim();
        }
        if (message.setAttribute !== undefined) {
            SetAttribute.encode(message.setAttribute, writer.uint32(50).fork()).ldelim();
        }
        if (message.removeNode !== undefined) {
            RemoveNode.encode(message.removeNode, writer.uint32(58).fork()).ldelim();
        }
        if (message.insertElement !== undefined) {
            InsertElement.encode(message.insertElement, writer.uint32(66).fork()).ldelim();
        }
        if (message.setFrameBounds !== undefined) {
            SetFrameBounds.encode(message.setFrameBounds, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMutation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mutationId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.int64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.moveElement = MoveElement.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.updateText = UpdateText.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.setInlineStyle = SetInlineStyle.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.setAttribute = SetAttribute.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.removeNode = RemoveNode.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.insertElement = InsertElement.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.setFrameBounds = SetFrameBounds.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
            moveElement: isSet(object.moveElement) ? MoveElement.fromJSON(object.moveElement) : undefined,
            updateText: isSet(object.updateText) ? UpdateText.fromJSON(object.updateText) : undefined,
            setInlineStyle: isSet(object.setInlineStyle) ? SetInlineStyle.fromJSON(object.setInlineStyle) : undefined,
            setAttribute: isSet(object.setAttribute) ? SetAttribute.fromJSON(object.setAttribute) : undefined,
            removeNode: isSet(object.removeNode) ? RemoveNode.fromJSON(object.removeNode) : undefined,
            insertElement: isSet(object.insertElement) ? InsertElement.fromJSON(object.insertElement) : undefined,
            setFrameBounds: isSet(object.setFrameBounds) ? SetFrameBounds.fromJSON(object.setFrameBounds) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mutationId !== "") {
            obj.mutationId = message.mutationId;
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        if (message.moveElement !== undefined) {
            obj.moveElement = MoveElement.toJSON(message.moveElement);
        }
        if (message.updateText !== undefined) {
            obj.updateText = UpdateText.toJSON(message.updateText);
        }
        if (message.setInlineStyle !== undefined) {
            obj.setInlineStyle = SetInlineStyle.toJSON(message.setInlineStyle);
        }
        if (message.setAttribute !== undefined) {
            obj.setAttribute = SetAttribute.toJSON(message.setAttribute);
        }
        if (message.removeNode !== undefined) {
            obj.removeNode = RemoveNode.toJSON(message.removeNode);
        }
        if (message.insertElement !== undefined) {
            obj.insertElement = InsertElement.toJSON(message.insertElement);
        }
        if (message.setFrameBounds !== undefined) {
            obj.setFrameBounds = SetFrameBounds.toJSON(message.setFrameBounds);
        }
        return obj;
    },
    create(base) {
        return Mutation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMutation();
        message.mutationId = object.mutationId ?? "";
        message.timestamp = object.timestamp ?? 0;
        message.moveElement = (object.moveElement !== undefined && object.moveElement !== null)
            ? MoveElement.fromPartial(object.moveElement)
            : undefined;
        message.updateText = (object.updateText !== undefined && object.updateText !== null)
            ? UpdateText.fromPartial(object.updateText)
            : undefined;
        message.setInlineStyle = (object.setInlineStyle !== undefined && object.setInlineStyle !== null)
            ? SetInlineStyle.fromPartial(object.setInlineStyle)
            : undefined;
        message.setAttribute = (object.setAttribute !== undefined && object.setAttribute !== null)
            ? SetAttribute.fromPartial(object.setAttribute)
            : undefined;
        message.removeNode = (object.removeNode !== undefined && object.removeNode !== null)
            ? RemoveNode.fromPartial(object.removeNode)
            : undefined;
        message.insertElement = (object.insertElement !== undefined && object.insertElement !== null)
            ? InsertElement.fromPartial(object.insertElement)
            : undefined;
        message.setFrameBounds = (object.setFrameBounds !== undefined && object.setFrameBounds !== null)
            ? SetFrameBounds.fromPartial(object.setFrameBounds)
            : undefined;
        return message;
    },
};
function createBaseSetFrameBounds() {
    return { frameId: "", bounds: undefined };
}
export const SetFrameBounds = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.frameId !== "") {
            writer.uint32(10).string(message.frameId);
        }
        if (message.bounds !== undefined) {
            Bounds.encode(message.bounds, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetFrameBounds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.frameId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bounds = Bounds.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            frameId: isSet(object.frameId) ? globalThis.String(object.frameId) : "",
            bounds: isSet(object.bounds) ? Bounds.fromJSON(object.bounds) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.frameId !== "") {
            obj.frameId = message.frameId;
        }
        if (message.bounds !== undefined) {
            obj.bounds = Bounds.toJSON(message.bounds);
        }
        return obj;
    },
    create(base) {
        return SetFrameBounds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetFrameBounds();
        message.frameId = object.frameId ?? "";
        message.bounds = (object.bounds !== undefined && object.bounds !== null)
            ? Bounds.fromPartial(object.bounds)
            : undefined;
        return message;
    },
};
function createBaseBounds() {
    return { x: 0, y: 0, width: 0, height: 0 };
}
export const Bounds = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(13).float(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(21).float(message.y);
        }
        if (message.width !== 0) {
            writer.uint32(29).float(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(37).float(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBounds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 13) {
                        break;
                    }
                    message.x = reader.float();
                    continue;
                case 2:
                    if (tag !== 21) {
                        break;
                    }
                    message.y = reader.float();
                    continue;
                case 3:
                    if (tag !== 29) {
                        break;
                    }
                    message.width = reader.float();
                    continue;
                case 4:
                    if (tag !== 37) {
                        break;
                    }
                    message.height = reader.float();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            x: isSet(object.x) ? globalThis.Number(object.x) : 0,
            y: isSet(object.y) ? globalThis.Number(object.y) : 0,
            width: isSet(object.width) ? globalThis.Number(object.width) : 0,
            height: isSet(object.height) ? globalThis.Number(object.height) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.x !== 0) {
            obj.x = message.x;
        }
        if (message.y !== 0) {
            obj.y = message.y;
        }
        if (message.width !== 0) {
            obj.width = message.width;
        }
        if (message.height !== 0) {
            obj.height = message.height;
        }
        return obj;
    },
    create(base) {
        return Bounds.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBounds();
        message.x = object.x ?? 0;
        message.y = object.y ?? 0;
        message.width = object.width ?? 0;
        message.height = object.height ?? 0;
        return message;
    },
};
function createBaseMoveElement() {
    return { nodeId: "", newParentId: "", index: 0 };
}
export const MoveElement = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.newParentId !== "") {
            writer.uint32(18).string(message.newParentId);
        }
        if (message.index !== 0) {
            writer.uint32(24).uint32(message.index);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMoveElement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.newParentId = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.index = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            newParentId: isSet(object.newParentId) ? globalThis.String(object.newParentId) : "",
            index: isSet(object.index) ? globalThis.Number(object.index) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.newParentId !== "") {
            obj.newParentId = message.newParentId;
        }
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        return obj;
    },
    create(base) {
        return MoveElement.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMoveElement();
        message.nodeId = object.nodeId ?? "";
        message.newParentId = object.newParentId ?? "";
        message.index = object.index ?? 0;
        return message;
    },
};
function createBaseUpdateText() {
    return { nodeId: "", content: "" };
}
export const UpdateText = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.content !== "") {
            writer.uint32(18).string(message.content);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateText();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.content = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            content: isSet(object.content) ? globalThis.String(object.content) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.content !== "") {
            obj.content = message.content;
        }
        return obj;
    },
    create(base) {
        return UpdateText.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateText();
        message.nodeId = object.nodeId ?? "";
        message.content = object.content ?? "";
        return message;
    },
};
function createBaseSetInlineStyle() {
    return { nodeId: "", property: "", value: "" };
}
export const SetInlineStyle = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.property !== "") {
            writer.uint32(18).string(message.property);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetInlineStyle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.property = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            property: isSet(object.property) ? globalThis.String(object.property) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.property !== "") {
            obj.property = message.property;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return SetInlineStyle.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetInlineStyle();
        message.nodeId = object.nodeId ?? "";
        message.property = object.property ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseSetAttribute() {
    return { nodeId: "", name: "", value: "" };
}
export const SetAttribute = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetAttribute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return SetAttribute.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSetAttribute();
        message.nodeId = object.nodeId ?? "";
        message.name = object.name ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseRemoveNode() {
    return { nodeId: "" };
}
export const RemoveNode = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        return obj;
    },
    create(base) {
        return RemoveNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRemoveNode();
        message.nodeId = object.nodeId ?? "";
        return message;
    },
};
function createBaseInsertElement() {
    return { parentId: "", index: 0, elementJson: "" };
}
export const InsertElement = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.parentId !== "") {
            writer.uint32(10).string(message.parentId);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        if (message.elementJson !== "") {
            writer.uint32(26).string(message.elementJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInsertElement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.parentId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.index = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.elementJson = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
            index: isSet(object.index) ? globalThis.Number(object.index) : 0,
            elementJson: isSet(object.elementJson) ? globalThis.String(object.elementJson) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.parentId !== "") {
            obj.parentId = message.parentId;
        }
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.elementJson !== "") {
            obj.elementJson = message.elementJson;
        }
        return obj;
    },
    create(base) {
        return InsertElement.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInsertElement();
        message.parentId = object.parentId ?? "";
        message.index = object.index ?? 0;
        message.elementJson = object.elementJson ?? "";
        return message;
    },
};
function createBaseOutlineRequest() {
    return { filePath: "" };
}
export const OutlineRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.filePath !== "") {
            writer.uint32(10).string(message.filePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutlineRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        return obj;
    },
    create(base) {
        return OutlineRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutlineRequest();
        message.filePath = object.filePath ?? "";
        return message;
    },
};
function createBaseOutlineResponse() {
    return { nodes: [], version: 0 };
}
export const OutlineResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.nodes) {
            OutlineNode.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.version !== 0) {
            writer.uint32(16).uint64(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutlineResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodes.push(OutlineNode.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.version = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e) => OutlineNode.fromJSON(e)) : [],
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodes?.length) {
            obj.nodes = message.nodes.map((e) => OutlineNode.toJSON(e));
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        return obj;
    },
    create(base) {
        return OutlineResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutlineResponse();
        message.nodes = object.nodes?.map((e) => OutlineNode.fromPartial(e)) || [];
        message.version = object.version ?? 0;
        return message;
    },
};
function createBaseOutlineNode() {
    return { nodeId: "", type: 0, parentId: undefined, childIds: [], span: undefined, label: undefined };
}
export const OutlineNode = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nodeId !== "") {
            writer.uint32(10).string(message.nodeId);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        if (message.parentId !== undefined) {
            writer.uint32(26).string(message.parentId);
        }
        for (const v of message.childIds) {
            writer.uint32(34).string(v);
        }
        if (message.span !== undefined) {
            SourceSpan.encode(message.span, writer.uint32(42).fork()).ldelim();
        }
        if (message.label !== undefined) {
            writer.uint32(50).string(message.label);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutlineNode();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nodeId = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.parentId = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.childIds.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.span = SourceSpan.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.label = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
            type: isSet(object.type) ? nodeTypeFromJSON(object.type) : 0,
            parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : undefined,
            childIds: globalThis.Array.isArray(object?.childIds) ? object.childIds.map((e) => globalThis.String(e)) : [],
            span: isSet(object.span) ? SourceSpan.fromJSON(object.span) : undefined,
            label: isSet(object.label) ? globalThis.String(object.label) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nodeId !== "") {
            obj.nodeId = message.nodeId;
        }
        if (message.type !== 0) {
            obj.type = nodeTypeToJSON(message.type);
        }
        if (message.parentId !== undefined) {
            obj.parentId = message.parentId;
        }
        if (message.childIds?.length) {
            obj.childIds = message.childIds;
        }
        if (message.span !== undefined) {
            obj.span = SourceSpan.toJSON(message.span);
        }
        if (message.label !== undefined) {
            obj.label = message.label;
        }
        return obj;
    },
    create(base) {
        return OutlineNode.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutlineNode();
        message.nodeId = object.nodeId ?? "";
        message.type = object.type ?? 0;
        message.parentId = object.parentId ?? undefined;
        message.childIds = object.childIds?.map((e) => e) || [];
        message.span = (object.span !== undefined && object.span !== null)
            ? SourceSpan.fromPartial(object.span)
            : undefined;
        message.label = object.label ?? undefined;
        return message;
    },
};
function createBaseSourceSpan() {
    return { startLine: 0, startCol: 0, endLine: 0, endCol: 0 };
}
export const SourceSpan = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.startLine !== 0) {
            writer.uint32(8).uint32(message.startLine);
        }
        if (message.startCol !== 0) {
            writer.uint32(16).uint32(message.startCol);
        }
        if (message.endLine !== 0) {
            writer.uint32(24).uint32(message.endLine);
        }
        if (message.endCol !== 0) {
            writer.uint32(32).uint32(message.endCol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSourceSpan();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.startLine = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.startCol = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.endLine = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.endCol = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            startLine: isSet(object.startLine) ? globalThis.Number(object.startLine) : 0,
            startCol: isSet(object.startCol) ? globalThis.Number(object.startCol) : 0,
            endLine: isSet(object.endLine) ? globalThis.Number(object.endLine) : 0,
            endCol: isSet(object.endCol) ? globalThis.Number(object.endCol) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.startLine !== 0) {
            obj.startLine = Math.round(message.startLine);
        }
        if (message.startCol !== 0) {
            obj.startCol = Math.round(message.startCol);
        }
        if (message.endLine !== 0) {
            obj.endLine = Math.round(message.endLine);
        }
        if (message.endCol !== 0) {
            obj.endCol = Math.round(message.endCol);
        }
        return obj;
    },
    create(base) {
        return SourceSpan.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSourceSpan();
        message.startLine = object.startLine ?? 0;
        message.startCol = object.startCol ?? 0;
        message.endLine = object.endLine ?? 0;
        message.endCol = object.endCol ?? 0;
        return message;
    },
};
function createBaseCrdtSyncRequest() {
    return { clientId: "", filePath: "", join: undefined, update: undefined, ack: undefined };
}
export const CrdtSyncRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.filePath !== "") {
            writer.uint32(18).string(message.filePath);
        }
        if (message.join !== undefined) {
            CrdtJoin.encode(message.join, writer.uint32(26).fork()).ldelim();
        }
        if (message.update !== undefined) {
            CrdtUpdate.encode(message.update, writer.uint32(34).fork()).ldelim();
        }
        if (message.ack !== undefined) {
            CrdtAck.encode(message.ack, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtSyncRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.join = CrdtJoin.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.update = CrdtUpdate.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.ack = CrdtAck.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            join: isSet(object.join) ? CrdtJoin.fromJSON(object.join) : undefined,
            update: isSet(object.update) ? CrdtUpdate.fromJSON(object.update) : undefined,
            ack: isSet(object.ack) ? CrdtAck.fromJSON(object.ack) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.join !== undefined) {
            obj.join = CrdtJoin.toJSON(message.join);
        }
        if (message.update !== undefined) {
            obj.update = CrdtUpdate.toJSON(message.update);
        }
        if (message.ack !== undefined) {
            obj.ack = CrdtAck.toJSON(message.ack);
        }
        return obj;
    },
    create(base) {
        return CrdtSyncRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtSyncRequest();
        message.clientId = object.clientId ?? "";
        message.filePath = object.filePath ?? "";
        message.join = (object.join !== undefined && object.join !== null) ? CrdtJoin.fromPartial(object.join) : undefined;
        message.update = (object.update !== undefined && object.update !== null)
            ? CrdtUpdate.fromPartial(object.update)
            : undefined;
        message.ack = (object.ack !== undefined && object.ack !== null) ? CrdtAck.fromPartial(object.ack) : undefined;
        return message;
    },
};
function createBaseCrdtJoin() {
    return { stateVector: new Uint8Array(0) };
}
export const CrdtJoin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.stateVector.length !== 0) {
            writer.uint32(10).bytes(message.stateVector);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtJoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.stateVector = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.stateVector.length !== 0) {
            obj.stateVector = base64FromBytes(message.stateVector);
        }
        return obj;
    },
    create(base) {
        return CrdtJoin.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtJoin();
        message.stateVector = object.stateVector ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCrdtUpdate() {
    return { update: new Uint8Array(0), stateVector: new Uint8Array(0), origin: "" };
}
export const CrdtUpdate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.update.length !== 0) {
            writer.uint32(10).bytes(message.update);
        }
        if (message.stateVector.length !== 0) {
            writer.uint32(18).bytes(message.stateVector);
        }
        if (message.origin !== "") {
            writer.uint32(26).string(message.origin);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.update = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.stateVector = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.origin = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            update: isSet(object.update) ? bytesFromBase64(object.update) : new Uint8Array(0),
            stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0),
            origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.update.length !== 0) {
            obj.update = base64FromBytes(message.update);
        }
        if (message.stateVector.length !== 0) {
            obj.stateVector = base64FromBytes(message.stateVector);
        }
        if (message.origin !== "") {
            obj.origin = message.origin;
        }
        return obj;
    },
    create(base) {
        return CrdtUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtUpdate();
        message.update = object.update ?? new Uint8Array(0);
        message.stateVector = object.stateVector ?? new Uint8Array(0);
        message.origin = object.origin ?? "";
        return message;
    },
};
function createBaseCrdtAck() {
    return { sequence: 0 };
}
export const CrdtAck = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sequence !== 0) {
            writer.uint32(8).uint64(message.sequence);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtAck();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sequence = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.sequence !== 0) {
            obj.sequence = Math.round(message.sequence);
        }
        return obj;
    },
    create(base) {
        return CrdtAck.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtAck();
        message.sequence = object.sequence ?? 0;
        return message;
    },
};
function createBaseCrdtSyncResponse() {
    return {
        welcome: undefined,
        remoteUpdate: undefined,
        vdomPatch: undefined,
        cssomPatch: undefined,
        parseError: undefined,
    };
}
export const CrdtSyncResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.welcome !== undefined) {
            CrdtWelcome.encode(message.welcome, writer.uint32(10).fork()).ldelim();
        }
        if (message.remoteUpdate !== undefined) {
            CrdtUpdate.encode(message.remoteUpdate, writer.uint32(18).fork()).ldelim();
        }
        if (message.vdomPatch !== undefined) {
            CrdtVdomPatch.encode(message.vdomPatch, writer.uint32(26).fork()).ldelim();
        }
        if (message.cssomPatch !== undefined) {
            CrdtCssomPatch.encode(message.cssomPatch, writer.uint32(34).fork()).ldelim();
        }
        if (message.parseError !== undefined) {
            CrdtParseError.encode(message.parseError, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtSyncResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.welcome = CrdtWelcome.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.remoteUpdate = CrdtUpdate.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.vdomPatch = CrdtVdomPatch.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.cssomPatch = CrdtCssomPatch.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.parseError = CrdtParseError.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            welcome: isSet(object.welcome) ? CrdtWelcome.fromJSON(object.welcome) : undefined,
            remoteUpdate: isSet(object.remoteUpdate) ? CrdtUpdate.fromJSON(object.remoteUpdate) : undefined,
            vdomPatch: isSet(object.vdomPatch) ? CrdtVdomPatch.fromJSON(object.vdomPatch) : undefined,
            cssomPatch: isSet(object.cssomPatch) ? CrdtCssomPatch.fromJSON(object.cssomPatch) : undefined,
            parseError: isSet(object.parseError) ? CrdtParseError.fromJSON(object.parseError) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.welcome !== undefined) {
            obj.welcome = CrdtWelcome.toJSON(message.welcome);
        }
        if (message.remoteUpdate !== undefined) {
            obj.remoteUpdate = CrdtUpdate.toJSON(message.remoteUpdate);
        }
        if (message.vdomPatch !== undefined) {
            obj.vdomPatch = CrdtVdomPatch.toJSON(message.vdomPatch);
        }
        if (message.cssomPatch !== undefined) {
            obj.cssomPatch = CrdtCssomPatch.toJSON(message.cssomPatch);
        }
        if (message.parseError !== undefined) {
            obj.parseError = CrdtParseError.toJSON(message.parseError);
        }
        return obj;
    },
    create(base) {
        return CrdtSyncResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtSyncResponse();
        message.welcome = (object.welcome !== undefined && object.welcome !== null)
            ? CrdtWelcome.fromPartial(object.welcome)
            : undefined;
        message.remoteUpdate = (object.remoteUpdate !== undefined && object.remoteUpdate !== null)
            ? CrdtUpdate.fromPartial(object.remoteUpdate)
            : undefined;
        message.vdomPatch = (object.vdomPatch !== undefined && object.vdomPatch !== null)
            ? CrdtVdomPatch.fromPartial(object.vdomPatch)
            : undefined;
        message.cssomPatch = (object.cssomPatch !== undefined && object.cssomPatch !== null)
            ? CrdtCssomPatch.fromPartial(object.cssomPatch)
            : undefined;
        message.parseError = (object.parseError !== undefined && object.parseError !== null)
            ? CrdtParseError.fromPartial(object.parseError)
            : undefined;
        return message;
    },
};
function createBaseCrdtWelcome() {
    return {
        documentState: new Uint8Array(0),
        stateVector: new Uint8Array(0),
        initialVdom: undefined,
        version: 0,
        clientCount: 0,
    };
}
export const CrdtWelcome = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.documentState.length !== 0) {
            writer.uint32(10).bytes(message.documentState);
        }
        if (message.stateVector.length !== 0) {
            writer.uint32(18).bytes(message.stateVector);
        }
        if (message.initialVdom !== undefined) {
            VDocPatch.encode(message.initialVdom, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== 0) {
            writer.uint32(32).uint64(message.version);
        }
        if (message.clientCount !== 0) {
            writer.uint32(40).uint32(message.clientCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtWelcome();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.documentState = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.stateVector = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.initialVdom = VDocPatch.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.version = longToNumber(reader.uint64());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.clientCount = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            documentState: isSet(object.documentState) ? bytesFromBase64(object.documentState) : new Uint8Array(0),
            stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0),
            initialVdom: isSet(object.initialVdom) ? VDocPatch.fromJSON(object.initialVdom) : undefined,
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
            clientCount: isSet(object.clientCount) ? globalThis.Number(object.clientCount) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.documentState.length !== 0) {
            obj.documentState = base64FromBytes(message.documentState);
        }
        if (message.stateVector.length !== 0) {
            obj.stateVector = base64FromBytes(message.stateVector);
        }
        if (message.initialVdom !== undefined) {
            obj.initialVdom = VDocPatch.toJSON(message.initialVdom);
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        if (message.clientCount !== 0) {
            obj.clientCount = Math.round(message.clientCount);
        }
        return obj;
    },
    create(base) {
        return CrdtWelcome.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtWelcome();
        message.documentState = object.documentState ?? new Uint8Array(0);
        message.stateVector = object.stateVector ?? new Uint8Array(0);
        message.initialVdom = (object.initialVdom !== undefined && object.initialVdom !== null)
            ? VDocPatch.fromPartial(object.initialVdom)
            : undefined;
        message.version = object.version ?? 0;
        message.clientCount = object.clientCount ?? 0;
        return message;
    },
};
function createBaseCrdtVdomPatch() {
    return { patches: [], version: 0, originClientId: "" };
}
export const CrdtVdomPatch = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.patches) {
            VDocPatch.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.version !== 0) {
            writer.uint32(16).uint64(message.version);
        }
        if (message.originClientId !== "") {
            writer.uint32(26).string(message.originClientId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtVdomPatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.patches.push(VDocPatch.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.version = longToNumber(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.originClientId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e) => VDocPatch.fromJSON(e)) : [],
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
            originClientId: isSet(object.originClientId) ? globalThis.String(object.originClientId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.patches?.length) {
            obj.patches = message.patches.map((e) => VDocPatch.toJSON(e));
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        if (message.originClientId !== "") {
            obj.originClientId = message.originClientId;
        }
        return obj;
    },
    create(base) {
        return CrdtVdomPatch.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtVdomPatch();
        message.patches = object.patches?.map((e) => VDocPatch.fromPartial(e)) || [];
        message.version = object.version ?? 0;
        message.originClientId = object.originClientId ?? "";
        return message;
    },
};
function createBaseCrdtCssomPatch() {
    return { rules: [], version: 0 };
}
export const CrdtCssomPatch = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rules) {
            CssRule.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.version !== 0) {
            writer.uint32(16).uint64(message.version);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtCssomPatch();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rules.push(CssRule.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.version = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e) => CssRule.fromJSON(e)) : [],
            version: isSet(object.version) ? globalThis.Number(object.version) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rules?.length) {
            obj.rules = message.rules.map((e) => CssRule.toJSON(e));
        }
        if (message.version !== 0) {
            obj.version = Math.round(message.version);
        }
        return obj;
    },
    create(base) {
        return CrdtCssomPatch.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtCssomPatch();
        message.rules = object.rules?.map((e) => CssRule.fromPartial(e)) || [];
        message.version = object.version ?? 0;
        return message;
    },
};
function createBaseCssRule() {
    return { selector: "", properties: {} };
}
export const CssRule = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.selector !== "") {
            writer.uint32(10).string(message.selector);
        }
        Object.entries(message.properties).forEach(([key, value]) => {
            CssRule_PropertiesEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCssRule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.selector = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = CssRule_PropertiesEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.properties[entry2.key] = entry2.value;
                    }
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            selector: isSet(object.selector) ? globalThis.String(object.selector) : "",
            properties: isObject(object.properties)
                ? Object.entries(object.properties).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.selector !== "") {
            obj.selector = message.selector;
        }
        if (message.properties) {
            const entries = Object.entries(message.properties);
            if (entries.length > 0) {
                obj.properties = {};
                entries.forEach(([k, v]) => {
                    obj.properties[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return CssRule.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCssRule();
        message.selector = object.selector ?? "";
        message.properties = Object.entries(object.properties ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseCssRule_PropertiesEntry() {
    return { key: "", value: "" };
}
export const CssRule_PropertiesEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCssRule_PropertiesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return CssRule_PropertiesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCssRule_PropertiesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseCrdtParseError() {
    return { error: "", line: 0, column: 0 };
}
export const CrdtParseError = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== "") {
            writer.uint32(10).string(message.error);
        }
        if (message.line !== 0) {
            writer.uint32(16).uint32(message.line);
        }
        if (message.column !== 0) {
            writer.uint32(24).uint32(message.column);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrdtParseError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.line = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.column = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            error: isSet(object.error) ? globalThis.String(object.error) : "",
            line: isSet(object.line) ? globalThis.Number(object.line) : 0,
            column: isSet(object.column) ? globalThis.Number(object.column) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.error !== "") {
            obj.error = message.error;
        }
        if (message.line !== 0) {
            obj.line = Math.round(message.line);
        }
        if (message.column !== 0) {
            obj.column = Math.round(message.column);
        }
        return obj;
    },
    create(base) {
        return CrdtParseError.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrdtParseError();
        message.error = object.error ?? "";
        message.line = object.line ?? 0;
        message.column = object.column ?? 0;
        return message;
    },
};
function createBaseBufferRequest() {
    return { clientId: "", filePath: "", content: "", expectedStateVersion: undefined };
}
export const BufferRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        if (message.filePath !== "") {
            writer.uint32(18).string(message.filePath);
        }
        if (message.content !== "") {
            writer.uint32(26).string(message.content);
        }
        if (message.expectedStateVersion !== undefined) {
            writer.uint32(32).uint64(message.expectedStateVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBufferRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.filePath = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.content = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.expectedStateVersion = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
            filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
            content: isSet(object.content) ? globalThis.String(object.content) : "",
            expectedStateVersion: isSet(object.expectedStateVersion)
                ? globalThis.Number(object.expectedStateVersion)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        if (message.filePath !== "") {
            obj.filePath = message.filePath;
        }
        if (message.content !== "") {
            obj.content = message.content;
        }
        if (message.expectedStateVersion !== undefined) {
            obj.expectedStateVersion = Math.round(message.expectedStateVersion);
        }
        return obj;
    },
    create(base) {
        return BufferRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBufferRequest();
        message.clientId = object.clientId ?? "";
        message.filePath = object.filePath ?? "";
        message.content = object.content ?? "";
        message.expectedStateVersion = object.expectedStateVersion ?? undefined;
        return message;
    },
};
function createBaseClosePreviewRequest() {
    return { clientId: "" };
}
export const ClosePreviewRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClosePreviewRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        return obj;
    },
    create(base) {
        return ClosePreviewRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClosePreviewRequest();
        message.clientId = object.clientId ?? "";
        return message;
    },
};
function createBaseClosePreviewResponse() {
    return { success: false, message: undefined };
}
export const ClosePreviewResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.message !== undefined) {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClosePreviewResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            message: isSet(object.message) ? globalThis.String(object.message) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.message !== undefined) {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return ClosePreviewResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClosePreviewResponse();
        message.success = object.success ?? false;
        message.message = object.message ?? undefined;
        return message;
    },
};
function createBaseHeartbeatRequest() {
    return { clientId: "" };
}
export const HeartbeatRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.clientId !== "") {
            writer.uint32(10).string(message.clientId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeartbeatRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.clientId = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientId !== "") {
            obj.clientId = message.clientId;
        }
        return obj;
    },
    create(base) {
        return HeartbeatRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHeartbeatRequest();
        message.clientId = object.clientId ?? "";
        return message;
    },
};
function createBaseHeartbeatResponse() {
    return { acknowledged: false, serverTime: 0 };
}
export const HeartbeatResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.acknowledged !== false) {
            writer.uint32(8).bool(message.acknowledged);
        }
        if (message.serverTime !== 0) {
            writer.uint32(16).uint64(message.serverTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeartbeatResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.acknowledged = reader.bool();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.serverTime = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
            serverTime: isSet(object.serverTime) ? globalThis.Number(object.serverTime) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.acknowledged !== false) {
            obj.acknowledged = message.acknowledged;
        }
        if (message.serverTime !== 0) {
            obj.serverTime = Math.round(message.serverTime);
        }
        return obj;
    },
    create(base) {
        return HeartbeatResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHeartbeatResponse();
        message.acknowledged = object.acknowledged ?? false;
        message.serverTime = object.serverTime ?? 0;
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=workspace.js.map