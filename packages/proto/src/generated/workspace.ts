// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: workspace.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { VDocPatch } from "./patches";

export const protobufPackage = "paperclip.workspace";

/** Node type enum */
export enum NodeType {
  COMPONENT = 0,
  ELEMENT = 1,
  TEXT = 2,
  CONDITIONAL = 3,
  REPEAT = 4,
  INSERT = 5,
  UNRECOGNIZED = -1,
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "COMPONENT":
      return NodeType.COMPONENT;
    case 1:
    case "ELEMENT":
      return NodeType.ELEMENT;
    case 2:
    case "TEXT":
      return NodeType.TEXT;
    case 3:
    case "CONDITIONAL":
      return NodeType.CONDITIONAL;
    case 4:
    case "REPEAT":
      return NodeType.REPEAT;
    case 5:
    case "INSERT":
      return NodeType.INSERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.COMPONENT:
      return "COMPONENT";
    case NodeType.ELEMENT:
      return "ELEMENT";
    case NodeType.TEXT:
      return "TEXT";
    case NodeType.CONDITIONAL:
      return "CONDITIONAL";
    case NodeType.REPEAT:
      return "REPEAT";
    case NodeType.INSERT:
      return "INSERT";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to start preview streaming */
export interface PreviewRequest {
  rootPath: string;
}

/** Preview update containing VDocument patches */
export interface PreviewUpdate {
  filePath: string;
  patches: VDocPatch[];
  error?: string | undefined;
  timestamp: number;
  version: number;
  /** NEW: Include mutation acknowledgments */
  acknowledgedMutationIds: string[];
  changedByClientId?: string | undefined;
}

/** Request to watch files */
export interface WatchRequest {
  directory: string;
  /** e.g., ["*.pc"] */
  patterns: string[];
}

/** File change event */
export interface FileEvent {
  eventType: FileEvent_EventType;
  filePath: string;
  timestamp: number;
}

export enum FileEvent_EventType {
  CREATED = 0,
  MODIFIED = 1,
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function fileEvent_EventTypeFromJSON(object: any): FileEvent_EventType {
  switch (object) {
    case 0:
    case "CREATED":
      return FileEvent_EventType.CREATED;
    case 1:
    case "MODIFIED":
      return FileEvent_EventType.MODIFIED;
    case 2:
    case "DELETED":
      return FileEvent_EventType.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileEvent_EventType.UNRECOGNIZED;
  }
}

export function fileEvent_EventTypeToJSON(object: FileEvent_EventType): string {
  switch (object) {
    case FileEvent_EventType.CREATED:
      return "CREATED";
    case FileEvent_EventType.MODIFIED:
      return "MODIFIED";
    case FileEvent_EventType.DELETED:
      return "DELETED";
    case FileEvent_EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to apply a semantic mutation */
export interface MutationRequest {
  clientId: string;
  filePath: string;
  mutation?:
    | Mutation
    | undefined;
  /** Optimistic concurrency control */
  expectedVersion: number;
}

/** Response to mutation application */
export interface MutationResponse {
  ack?: MutationAck | undefined;
  rebased?: MutationRebased | undefined;
  noop?: MutationNoop | undefined;
}

/** Mutation was accepted and applied */
export interface MutationAck {
  mutationId: string;
  newVersion: number;
  timestamp: number;
}

/** Mutation was transformed (rebased) due to concurrent changes */
export interface MutationRebased {
  originalMutationId: string;
  transformedMutation?: Mutation | undefined;
  newVersion: number;
  reason: string;
}

/** Mutation had no effect (e.g., node already deleted) */
export interface MutationNoop {
  mutationId: string;
  reason: string;
}

/** Semantic AST operation */
export interface Mutation {
  mutationId: string;
  timestamp: number;
  moveElement?: MoveElement | undefined;
  updateText?: UpdateText | undefined;
  setInlineStyle?: SetInlineStyle | undefined;
  setAttribute?: SetAttribute | undefined;
  removeNode?: RemoveNode | undefined;
  insertElement?: InsertElement | undefined;
}

/** Move an element to a new parent at index */
export interface MoveElement {
  nodeId: string;
  newParentId: string;
  index: number;
}

/** Update text content (atomic replacement) */
export interface UpdateText {
  nodeId: string;
  content: string;
}

/** Set an inline style property */
export interface SetInlineStyle {
  nodeId: string;
  property: string;
  value: string;
}

/** Set an attribute value */
export interface SetAttribute {
  nodeId: string;
  name: string;
  value: string;
}

/** Remove a node from the tree */
export interface RemoveNode {
  nodeId: string;
}

/** Insert a new element (rare - most creation via templates) */
export interface InsertElement {
  parentId: string;
  index: number;
  /** Serialized AST element */
  elementJson: string;
}

/** Request document outline */
export interface OutlineRequest {
  filePath: string;
}

/** Document outline response */
export interface OutlineResponse {
  nodes: OutlineNode[];
  version: number;
}

/** Single node in document outline */
export interface OutlineNode {
  nodeId: string;
  type: NodeType;
  parentId?: string | undefined;
  childIds: string[];
  span?:
    | SourceSpan
    | undefined;
  /** e.g., component name, tag name */
  label?: string | undefined;
}

/** Source code location */
export interface SourceSpan {
  startLine: number;
  startCol: number;
  endLine: number;
  endCol: number;
}

/** Request to stream buffer content directly (no file I/O) */
export interface BufferRequest {
  clientId: string;
  filePath: string;
  content: string;
  /** Version-based sync for reconnection handling */
  expectedStateVersion?: number | undefined;
}

/** Request to close preview and cleanup state */
export interface ClosePreviewRequest {
  clientId: string;
}

/** Response confirming state cleanup */
export interface ClosePreviewResponse {
  success: boolean;
  message?: string | undefined;
}

/** Heartbeat request for liveness tracking */
export interface HeartbeatRequest {
  clientId: string;
}

/** Heartbeat response */
export interface HeartbeatResponse {
  acknowledged: boolean;
  serverTime: number;
}

function createBasePreviewRequest(): PreviewRequest {
  return { rootPath: "" };
}

export const PreviewRequest = {
  encode(message: PreviewRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rootPath !== "") {
      writer.uint32(10).string(message.rootPath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreviewRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rootPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewRequest {
    return { rootPath: isSet(object.rootPath) ? globalThis.String(object.rootPath) : "" };
  },

  toJSON(message: PreviewRequest): unknown {
    const obj: any = {};
    if (message.rootPath !== "") {
      obj.rootPath = message.rootPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewRequest>, I>>(base?: I): PreviewRequest {
    return PreviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewRequest>, I>>(object: I): PreviewRequest {
    const message = createBasePreviewRequest();
    message.rootPath = object.rootPath ?? "";
    return message;
  },
};

function createBasePreviewUpdate(): PreviewUpdate {
  return {
    filePath: "",
    patches: [],
    error: undefined,
    timestamp: 0,
    version: 0,
    acknowledgedMutationIds: [],
    changedByClientId: undefined,
  };
}

export const PreviewUpdate = {
  encode(message: PreviewUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    for (const v of message.patches) {
      VDocPatch.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.version !== 0) {
      writer.uint32(40).uint64(message.version);
    }
    for (const v of message.acknowledgedMutationIds) {
      writer.uint32(50).string(v!);
    }
    if (message.changedByClientId !== undefined) {
      writer.uint32(58).string(message.changedByClientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreviewUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.patches.push(VDocPatch.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.acknowledgedMutationIds.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.changedByClientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewUpdate {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e: any) => VDocPatch.fromJSON(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      acknowledgedMutationIds: globalThis.Array.isArray(object?.acknowledgedMutationIds)
        ? object.acknowledgedMutationIds.map((e: any) => globalThis.String(e))
        : [],
      changedByClientId: isSet(object.changedByClientId) ? globalThis.String(object.changedByClientId) : undefined,
    };
  },

  toJSON(message: PreviewUpdate): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.patches?.length) {
      obj.patches = message.patches.map((e) => VDocPatch.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.acknowledgedMutationIds?.length) {
      obj.acknowledgedMutationIds = message.acknowledgedMutationIds;
    }
    if (message.changedByClientId !== undefined) {
      obj.changedByClientId = message.changedByClientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewUpdate>, I>>(base?: I): PreviewUpdate {
    return PreviewUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewUpdate>, I>>(object: I): PreviewUpdate {
    const message = createBasePreviewUpdate();
    message.filePath = object.filePath ?? "";
    message.patches = object.patches?.map((e) => VDocPatch.fromPartial(e)) || [];
    message.error = object.error ?? undefined;
    message.timestamp = object.timestamp ?? 0;
    message.version = object.version ?? 0;
    message.acknowledgedMutationIds = object.acknowledgedMutationIds?.map((e) => e) || [];
    message.changedByClientId = object.changedByClientId ?? undefined;
    return message;
  },
};

function createBaseWatchRequest(): WatchRequest {
  return { directory: "", patterns: [] };
}

export const WatchRequest = {
  encode(message: WatchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.directory !== "") {
      writer.uint32(10).string(message.directory);
    }
    for (const v of message.patterns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.directory = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.patterns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchRequest {
    return {
      directory: isSet(object.directory) ? globalThis.String(object.directory) : "",
      patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: WatchRequest): unknown {
    const obj: any = {};
    if (message.directory !== "") {
      obj.directory = message.directory;
    }
    if (message.patterns?.length) {
      obj.patterns = message.patterns;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchRequest>, I>>(base?: I): WatchRequest {
    return WatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchRequest>, I>>(object: I): WatchRequest {
    const message = createBaseWatchRequest();
    message.directory = object.directory ?? "";
    message.patterns = object.patterns?.map((e) => e) || [];
    return message;
  },
};

function createBaseFileEvent(): FileEvent {
  return { eventType: 0, filePath: "", timestamp: 0 };
}

export const FileEvent = {
  encode(message: FileEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileEvent {
    return {
      eventType: isSet(object.eventType) ? fileEvent_EventTypeFromJSON(object.eventType) : 0,
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: FileEvent): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = fileEvent_EventTypeToJSON(message.eventType);
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileEvent>, I>>(base?: I): FileEvent {
    return FileEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileEvent>, I>>(object: I): FileEvent {
    const message = createBaseFileEvent();
    message.eventType = object.eventType ?? 0;
    message.filePath = object.filePath ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseMutationRequest(): MutationRequest {
  return { clientId: "", filePath: "", mutation: undefined, expectedVersion: 0 };
}

export const MutationRequest = {
  encode(message: MutationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.mutation !== undefined) {
      Mutation.encode(message.mutation, writer.uint32(26).fork()).ldelim();
    }
    if (message.expectedVersion !== 0) {
      writer.uint32(32).uint64(message.expectedVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mutation = Mutation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expectedVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      mutation: isSet(object.mutation) ? Mutation.fromJSON(object.mutation) : undefined,
      expectedVersion: isSet(object.expectedVersion) ? globalThis.Number(object.expectedVersion) : 0,
    };
  },

  toJSON(message: MutationRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.mutation !== undefined) {
      obj.mutation = Mutation.toJSON(message.mutation);
    }
    if (message.expectedVersion !== 0) {
      obj.expectedVersion = Math.round(message.expectedVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationRequest>, I>>(base?: I): MutationRequest {
    return MutationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationRequest>, I>>(object: I): MutationRequest {
    const message = createBaseMutationRequest();
    message.clientId = object.clientId ?? "";
    message.filePath = object.filePath ?? "";
    message.mutation = (object.mutation !== undefined && object.mutation !== null)
      ? Mutation.fromPartial(object.mutation)
      : undefined;
    message.expectedVersion = object.expectedVersion ?? 0;
    return message;
  },
};

function createBaseMutationResponse(): MutationResponse {
  return { ack: undefined, rebased: undefined, noop: undefined };
}

export const MutationResponse = {
  encode(message: MutationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ack !== undefined) {
      MutationAck.encode(message.ack, writer.uint32(10).fork()).ldelim();
    }
    if (message.rebased !== undefined) {
      MutationRebased.encode(message.rebased, writer.uint32(18).fork()).ldelim();
    }
    if (message.noop !== undefined) {
      MutationNoop.encode(message.noop, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ack = MutationAck.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rebased = MutationRebased.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noop = MutationNoop.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationResponse {
    return {
      ack: isSet(object.ack) ? MutationAck.fromJSON(object.ack) : undefined,
      rebased: isSet(object.rebased) ? MutationRebased.fromJSON(object.rebased) : undefined,
      noop: isSet(object.noop) ? MutationNoop.fromJSON(object.noop) : undefined,
    };
  },

  toJSON(message: MutationResponse): unknown {
    const obj: any = {};
    if (message.ack !== undefined) {
      obj.ack = MutationAck.toJSON(message.ack);
    }
    if (message.rebased !== undefined) {
      obj.rebased = MutationRebased.toJSON(message.rebased);
    }
    if (message.noop !== undefined) {
      obj.noop = MutationNoop.toJSON(message.noop);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationResponse>, I>>(base?: I): MutationResponse {
    return MutationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationResponse>, I>>(object: I): MutationResponse {
    const message = createBaseMutationResponse();
    message.ack = (object.ack !== undefined && object.ack !== null) ? MutationAck.fromPartial(object.ack) : undefined;
    message.rebased = (object.rebased !== undefined && object.rebased !== null)
      ? MutationRebased.fromPartial(object.rebased)
      : undefined;
    message.noop = (object.noop !== undefined && object.noop !== null)
      ? MutationNoop.fromPartial(object.noop)
      : undefined;
    return message;
  },
};

function createBaseMutationAck(): MutationAck {
  return { mutationId: "", newVersion: 0, timestamp: 0 };
}

export const MutationAck = {
  encode(message: MutationAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.newVersion !== 0) {
      writer.uint32(16).uint64(message.newVersion);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newVersion = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAck {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: MutationAck): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.newVersion !== 0) {
      obj.newVersion = Math.round(message.newVersion);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationAck>, I>>(base?: I): MutationAck {
    return MutationAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationAck>, I>>(object: I): MutationAck {
    const message = createBaseMutationAck();
    message.mutationId = object.mutationId ?? "";
    message.newVersion = object.newVersion ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseMutationRebased(): MutationRebased {
  return { originalMutationId: "", transformedMutation: undefined, newVersion: 0, reason: "" };
}

export const MutationRebased = {
  encode(message: MutationRebased, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originalMutationId !== "") {
      writer.uint32(10).string(message.originalMutationId);
    }
    if (message.transformedMutation !== undefined) {
      Mutation.encode(message.transformedMutation, writer.uint32(18).fork()).ldelim();
    }
    if (message.newVersion !== 0) {
      writer.uint32(24).uint64(message.newVersion);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationRebased {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationRebased();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalMutationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transformedMutation = Mutation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.newVersion = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationRebased {
    return {
      originalMutationId: isSet(object.originalMutationId) ? globalThis.String(object.originalMutationId) : "",
      transformedMutation: isSet(object.transformedMutation)
        ? Mutation.fromJSON(object.transformedMutation)
        : undefined,
      newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MutationRebased): unknown {
    const obj: any = {};
    if (message.originalMutationId !== "") {
      obj.originalMutationId = message.originalMutationId;
    }
    if (message.transformedMutation !== undefined) {
      obj.transformedMutation = Mutation.toJSON(message.transformedMutation);
    }
    if (message.newVersion !== 0) {
      obj.newVersion = Math.round(message.newVersion);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationRebased>, I>>(base?: I): MutationRebased {
    return MutationRebased.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationRebased>, I>>(object: I): MutationRebased {
    const message = createBaseMutationRebased();
    message.originalMutationId = object.originalMutationId ?? "";
    message.transformedMutation = (object.transformedMutation !== undefined && object.transformedMutation !== null)
      ? Mutation.fromPartial(object.transformedMutation)
      : undefined;
    message.newVersion = object.newVersion ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMutationNoop(): MutationNoop {
  return { mutationId: "", reason: "" };
}

export const MutationNoop = {
  encode(message: MutationNoop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationNoop {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationNoop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationNoop {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MutationNoop): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationNoop>, I>>(base?: I): MutationNoop {
    return MutationNoop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationNoop>, I>>(object: I): MutationNoop {
    const message = createBaseMutationNoop();
    message.mutationId = object.mutationId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMutation(): Mutation {
  return {
    mutationId: "",
    timestamp: 0,
    moveElement: undefined,
    updateText: undefined,
    setInlineStyle: undefined,
    setAttribute: undefined,
    removeNode: undefined,
    insertElement: undefined,
  };
}

export const Mutation = {
  encode(message: Mutation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.moveElement !== undefined) {
      MoveElement.encode(message.moveElement, writer.uint32(26).fork()).ldelim();
    }
    if (message.updateText !== undefined) {
      UpdateText.encode(message.updateText, writer.uint32(34).fork()).ldelim();
    }
    if (message.setInlineStyle !== undefined) {
      SetInlineStyle.encode(message.setInlineStyle, writer.uint32(42).fork()).ldelim();
    }
    if (message.setAttribute !== undefined) {
      SetAttribute.encode(message.setAttribute, writer.uint32(50).fork()).ldelim();
    }
    if (message.removeNode !== undefined) {
      RemoveNode.encode(message.removeNode, writer.uint32(58).fork()).ldelim();
    }
    if (message.insertElement !== undefined) {
      InsertElement.encode(message.insertElement, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Mutation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.moveElement = MoveElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateText = UpdateText.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.setInlineStyle = SetInlineStyle.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.setAttribute = SetAttribute.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.removeNode = RemoveNode.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.insertElement = InsertElement.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      moveElement: isSet(object.moveElement) ? MoveElement.fromJSON(object.moveElement) : undefined,
      updateText: isSet(object.updateText) ? UpdateText.fromJSON(object.updateText) : undefined,
      setInlineStyle: isSet(object.setInlineStyle) ? SetInlineStyle.fromJSON(object.setInlineStyle) : undefined,
      setAttribute: isSet(object.setAttribute) ? SetAttribute.fromJSON(object.setAttribute) : undefined,
      removeNode: isSet(object.removeNode) ? RemoveNode.fromJSON(object.removeNode) : undefined,
      insertElement: isSet(object.insertElement) ? InsertElement.fromJSON(object.insertElement) : undefined,
    };
  },

  toJSON(message: Mutation): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.moveElement !== undefined) {
      obj.moveElement = MoveElement.toJSON(message.moveElement);
    }
    if (message.updateText !== undefined) {
      obj.updateText = UpdateText.toJSON(message.updateText);
    }
    if (message.setInlineStyle !== undefined) {
      obj.setInlineStyle = SetInlineStyle.toJSON(message.setInlineStyle);
    }
    if (message.setAttribute !== undefined) {
      obj.setAttribute = SetAttribute.toJSON(message.setAttribute);
    }
    if (message.removeNode !== undefined) {
      obj.removeNode = RemoveNode.toJSON(message.removeNode);
    }
    if (message.insertElement !== undefined) {
      obj.insertElement = InsertElement.toJSON(message.insertElement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mutation>, I>>(base?: I): Mutation {
    return Mutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mutation>, I>>(object: I): Mutation {
    const message = createBaseMutation();
    message.mutationId = object.mutationId ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.moveElement = (object.moveElement !== undefined && object.moveElement !== null)
      ? MoveElement.fromPartial(object.moveElement)
      : undefined;
    message.updateText = (object.updateText !== undefined && object.updateText !== null)
      ? UpdateText.fromPartial(object.updateText)
      : undefined;
    message.setInlineStyle = (object.setInlineStyle !== undefined && object.setInlineStyle !== null)
      ? SetInlineStyle.fromPartial(object.setInlineStyle)
      : undefined;
    message.setAttribute = (object.setAttribute !== undefined && object.setAttribute !== null)
      ? SetAttribute.fromPartial(object.setAttribute)
      : undefined;
    message.removeNode = (object.removeNode !== undefined && object.removeNode !== null)
      ? RemoveNode.fromPartial(object.removeNode)
      : undefined;
    message.insertElement = (object.insertElement !== undefined && object.insertElement !== null)
      ? InsertElement.fromPartial(object.insertElement)
      : undefined;
    return message;
  },
};

function createBaseMoveElement(): MoveElement {
  return { nodeId: "", newParentId: "", index: 0 };
}

export const MoveElement = {
  encode(message: MoveElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.newParentId !== "") {
      writer.uint32(18).string(message.newParentId);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoveElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newParentId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveElement {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      newParentId: isSet(object.newParentId) ? globalThis.String(object.newParentId) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: MoveElement): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.newParentId !== "") {
      obj.newParentId = message.newParentId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveElement>, I>>(base?: I): MoveElement {
    return MoveElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveElement>, I>>(object: I): MoveElement {
    const message = createBaseMoveElement();
    message.nodeId = object.nodeId ?? "";
    message.newParentId = object.newParentId ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseUpdateText(): UpdateText {
  return { nodeId: "", content: "" };
}

export const UpdateText = {
  encode(message: UpdateText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateText {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: UpdateText): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateText>, I>>(base?: I): UpdateText {
    return UpdateText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateText>, I>>(object: I): UpdateText {
    const message = createBaseUpdateText();
    message.nodeId = object.nodeId ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSetInlineStyle(): SetInlineStyle {
  return { nodeId: "", property: "", value: "" };
}

export const SetInlineStyle = {
  encode(message: SetInlineStyle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.property !== "") {
      writer.uint32(18).string(message.property);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetInlineStyle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetInlineStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.property = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetInlineStyle {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetInlineStyle): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetInlineStyle>, I>>(base?: I): SetInlineStyle {
    return SetInlineStyle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetInlineStyle>, I>>(object: I): SetInlineStyle {
    const message = createBaseSetInlineStyle();
    message.nodeId = object.nodeId ?? "";
    message.property = object.property ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetAttribute(): SetAttribute {
  return { nodeId: "", name: "", value: "" };
}

export const SetAttribute = {
  encode(message: SetAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAttribute {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetAttribute): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAttribute>, I>>(base?: I): SetAttribute {
    return SetAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAttribute>, I>>(object: I): SetAttribute {
    const message = createBaseSetAttribute();
    message.nodeId = object.nodeId ?? "";
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRemoveNode(): RemoveNode {
  return { nodeId: "" };
}

export const RemoveNode = {
  encode(message: RemoveNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveNode {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: RemoveNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveNode>, I>>(base?: I): RemoveNode {
    return RemoveNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveNode>, I>>(object: I): RemoveNode {
    const message = createBaseRemoveNode();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseInsertElement(): InsertElement {
  return { parentId: "", index: 0, elementJson: "" };
}

export const InsertElement = {
  encode(message: InsertElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parentId !== "") {
      writer.uint32(10).string(message.parentId);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.elementJson !== "") {
      writer.uint32(26).string(message.elementJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.elementJson = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertElement {
    return {
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      elementJson: isSet(object.elementJson) ? globalThis.String(object.elementJson) : "",
    };
  },

  toJSON(message: InsertElement): unknown {
    const obj: any = {};
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.elementJson !== "") {
      obj.elementJson = message.elementJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertElement>, I>>(base?: I): InsertElement {
    return InsertElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertElement>, I>>(object: I): InsertElement {
    const message = createBaseInsertElement();
    message.parentId = object.parentId ?? "";
    message.index = object.index ?? 0;
    message.elementJson = object.elementJson ?? "";
    return message;
  },
};

function createBaseOutlineRequest(): OutlineRequest {
  return { filePath: "" };
}

export const OutlineRequest = {
  encode(message: OutlineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineRequest {
    return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "" };
  },

  toJSON(message: OutlineRequest): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineRequest>, I>>(base?: I): OutlineRequest {
    return OutlineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineRequest>, I>>(object: I): OutlineRequest {
    const message = createBaseOutlineRequest();
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBaseOutlineResponse(): OutlineResponse {
  return { nodes: [], version: 0 };
}

export const OutlineResponse = {
  encode(message: OutlineResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodes) {
      OutlineNode.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(16).uint64(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(OutlineNode.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => OutlineNode.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: OutlineResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => OutlineNode.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineResponse>, I>>(base?: I): OutlineResponse {
    return OutlineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineResponse>, I>>(object: I): OutlineResponse {
    const message = createBaseOutlineResponse();
    message.nodes = object.nodes?.map((e) => OutlineNode.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseOutlineNode(): OutlineNode {
  return { nodeId: "", type: 0, parentId: undefined, childIds: [], span: undefined, label: undefined };
}

export const OutlineNode = {
  encode(message: OutlineNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.parentId !== undefined) {
      writer.uint32(26).string(message.parentId);
    }
    for (const v of message.childIds) {
      writer.uint32(34).string(v!);
    }
    if (message.span !== undefined) {
      SourceSpan.encode(message.span, writer.uint32(42).fork()).ldelim();
    }
    if (message.label !== undefined) {
      writer.uint32(50).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.childIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.span = SourceSpan.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      type: isSet(object.type) ? nodeTypeFromJSON(object.type) : 0,
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : undefined,
      childIds: globalThis.Array.isArray(object?.childIds) ? object.childIds.map((e: any) => globalThis.String(e)) : [],
      span: isSet(object.span) ? SourceSpan.fromJSON(object.span) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
    };
  },

  toJSON(message: OutlineNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.type !== 0) {
      obj.type = nodeTypeToJSON(message.type);
    }
    if (message.parentId !== undefined) {
      obj.parentId = message.parentId;
    }
    if (message.childIds?.length) {
      obj.childIds = message.childIds;
    }
    if (message.span !== undefined) {
      obj.span = SourceSpan.toJSON(message.span);
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineNode>, I>>(base?: I): OutlineNode {
    return OutlineNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineNode>, I>>(object: I): OutlineNode {
    const message = createBaseOutlineNode();
    message.nodeId = object.nodeId ?? "";
    message.type = object.type ?? 0;
    message.parentId = object.parentId ?? undefined;
    message.childIds = object.childIds?.map((e) => e) || [];
    message.span = (object.span !== undefined && object.span !== null)
      ? SourceSpan.fromPartial(object.span)
      : undefined;
    message.label = object.label ?? undefined;
    return message;
  },
};

function createBaseSourceSpan(): SourceSpan {
  return { startLine: 0, startCol: 0, endLine: 0, endCol: 0 };
}

export const SourceSpan = {
  encode(message: SourceSpan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startLine !== 0) {
      writer.uint32(8).uint32(message.startLine);
    }
    if (message.startCol !== 0) {
      writer.uint32(16).uint32(message.startCol);
    }
    if (message.endLine !== 0) {
      writer.uint32(24).uint32(message.endLine);
    }
    if (message.endCol !== 0) {
      writer.uint32(32).uint32(message.endCol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceSpan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startLine = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startCol = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endLine = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.endCol = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceSpan {
    return {
      startLine: isSet(object.startLine) ? globalThis.Number(object.startLine) : 0,
      startCol: isSet(object.startCol) ? globalThis.Number(object.startCol) : 0,
      endLine: isSet(object.endLine) ? globalThis.Number(object.endLine) : 0,
      endCol: isSet(object.endCol) ? globalThis.Number(object.endCol) : 0,
    };
  },

  toJSON(message: SourceSpan): unknown {
    const obj: any = {};
    if (message.startLine !== 0) {
      obj.startLine = Math.round(message.startLine);
    }
    if (message.startCol !== 0) {
      obj.startCol = Math.round(message.startCol);
    }
    if (message.endLine !== 0) {
      obj.endLine = Math.round(message.endLine);
    }
    if (message.endCol !== 0) {
      obj.endCol = Math.round(message.endCol);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceSpan>, I>>(base?: I): SourceSpan {
    return SourceSpan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceSpan>, I>>(object: I): SourceSpan {
    const message = createBaseSourceSpan();
    message.startLine = object.startLine ?? 0;
    message.startCol = object.startCol ?? 0;
    message.endLine = object.endLine ?? 0;
    message.endCol = object.endCol ?? 0;
    return message;
  },
};

function createBaseBufferRequest(): BufferRequest {
  return { clientId: "", filePath: "", content: "", expectedStateVersion: undefined };
}

export const BufferRequest = {
  encode(message: BufferRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.expectedStateVersion !== undefined) {
      writer.uint32(32).uint64(message.expectedStateVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BufferRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expectedStateVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      expectedStateVersion: isSet(object.expectedStateVersion)
        ? globalThis.Number(object.expectedStateVersion)
        : undefined,
    };
  },

  toJSON(message: BufferRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.expectedStateVersion !== undefined) {
      obj.expectedStateVersion = Math.round(message.expectedStateVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferRequest>, I>>(base?: I): BufferRequest {
    return BufferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferRequest>, I>>(object: I): BufferRequest {
    const message = createBaseBufferRequest();
    message.clientId = object.clientId ?? "";
    message.filePath = object.filePath ?? "";
    message.content = object.content ?? "";
    message.expectedStateVersion = object.expectedStateVersion ?? undefined;
    return message;
  },
};

function createBaseClosePreviewRequest(): ClosePreviewRequest {
  return { clientId: "" };
}

export const ClosePreviewRequest = {
  encode(message: ClosePreviewRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClosePreviewRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosePreviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosePreviewRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: ClosePreviewRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosePreviewRequest>, I>>(base?: I): ClosePreviewRequest {
    return ClosePreviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosePreviewRequest>, I>>(object: I): ClosePreviewRequest {
    const message = createBaseClosePreviewRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseClosePreviewResponse(): ClosePreviewResponse {
  return { success: false, message: undefined };
}

export const ClosePreviewResponse = {
  encode(message: ClosePreviewResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClosePreviewResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosePreviewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosePreviewResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: ClosePreviewResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosePreviewResponse>, I>>(base?: I): ClosePreviewResponse {
    return ClosePreviewResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosePreviewResponse>, I>>(object: I): ClosePreviewResponse {
    const message = createBaseClosePreviewResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return { clientId: "" };
}

export const HeartbeatRequest = {
  encode(message: HeartbeatRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(base?: I): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(object: I): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseHeartbeatResponse(): HeartbeatResponse {
  return { acknowledged: false, serverTime: 0 };
}

export const HeartbeatResponse = {
  encode(message: HeartbeatResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acknowledged !== false) {
      writer.uint32(8).bool(message.acknowledged);
    }
    if (message.serverTime !== 0) {
      writer.uint32(16).uint64(message.serverTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverTime = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatResponse {
    return {
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
      serverTime: isSet(object.serverTime) ? globalThis.Number(object.serverTime) : 0,
    };
  },

  toJSON(message: HeartbeatResponse): unknown {
    const obj: any = {};
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    if (message.serverTime !== 0) {
      obj.serverTime = Math.round(message.serverTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(base?: I): HeartbeatResponse {
    return HeartbeatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(object: I): HeartbeatResponse {
    const message = createBaseHeartbeatResponse();
    message.acknowledged = object.acknowledged ?? false;
    message.serverTime = object.serverTime ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
