// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: workspace.proto

/* eslint-disable */
import Long from "long";
import * as _m0 from "protobufjs/minimal";
import { VDocPatch } from "./patches";

export const protobufPackage = "paperclip.workspace";

/** Node type enum */
export enum NodeType {
  COMPONENT = 0,
  ELEMENT = 1,
  TEXT = 2,
  CONDITIONAL = 3,
  REPEAT = 4,
  INSERT = 5,
  UNRECOGNIZED = -1,
}

export function nodeTypeFromJSON(object: any): NodeType {
  switch (object) {
    case 0:
    case "COMPONENT":
      return NodeType.COMPONENT;
    case 1:
    case "ELEMENT":
      return NodeType.ELEMENT;
    case 2:
    case "TEXT":
      return NodeType.TEXT;
    case 3:
    case "CONDITIONAL":
      return NodeType.CONDITIONAL;
    case 4:
    case "REPEAT":
      return NodeType.REPEAT;
    case 5:
    case "INSERT":
      return NodeType.INSERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType.UNRECOGNIZED;
  }
}

export function nodeTypeToJSON(object: NodeType): string {
  switch (object) {
    case NodeType.COMPONENT:
      return "COMPONENT";
    case NodeType.ELEMENT:
      return "ELEMENT";
    case NodeType.TEXT:
      return "TEXT";
    case NodeType.CONDITIONAL:
      return "CONDITIONAL";
    case NodeType.REPEAT:
      return "REPEAT";
    case NodeType.INSERT:
      return "INSERT";
    case NodeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to start preview streaming */
export interface PreviewRequest {
  rootPath: string;
}

/** Preview update containing VDocument patches */
export interface PreviewUpdate {
  filePath: string;
  patches: VDocPatch[];
  error?: string | undefined;
  timestamp: number;
  version: number;
  /** NEW: Include mutation acknowledgments */
  acknowledgedMutationIds: string[];
  changedByClientId?: string | undefined;
}

/** Request to watch files */
export interface WatchRequest {
  directory: string;
  /** e.g., ["*.pc"] */
  patterns: string[];
}

/** File change event */
export interface FileEvent {
  eventType: FileEvent_EventType;
  filePath: string;
  timestamp: number;
}

export enum FileEvent_EventType {
  CREATED = 0,
  MODIFIED = 1,
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function fileEvent_EventTypeFromJSON(object: any): FileEvent_EventType {
  switch (object) {
    case 0:
    case "CREATED":
      return FileEvent_EventType.CREATED;
    case 1:
    case "MODIFIED":
      return FileEvent_EventType.MODIFIED;
    case 2:
    case "DELETED":
      return FileEvent_EventType.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileEvent_EventType.UNRECOGNIZED;
  }
}

export function fileEvent_EventTypeToJSON(object: FileEvent_EventType): string {
  switch (object) {
    case FileEvent_EventType.CREATED:
      return "CREATED";
    case FileEvent_EventType.MODIFIED:
      return "MODIFIED";
    case FileEvent_EventType.DELETED:
      return "DELETED";
    case FileEvent_EventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to apply a semantic mutation */
export interface MutationRequest {
  clientId: string;
  filePath: string;
  mutation?:
    | Mutation
    | undefined;
  /** Optimistic concurrency control */
  expectedVersion: number;
}

/** Response to mutation application */
export interface MutationResponse {
  ack?: MutationAck | undefined;
  rebased?: MutationRebased | undefined;
  noop?: MutationNoop | undefined;
}

/** Mutation was accepted and applied */
export interface MutationAck {
  mutationId: string;
  newVersion: number;
  timestamp: number;
}

/** Mutation was transformed (rebased) due to concurrent changes */
export interface MutationRebased {
  originalMutationId: string;
  transformedMutation?: Mutation | undefined;
  newVersion: number;
  reason: string;
}

/** Mutation had no effect (e.g., node already deleted) */
export interface MutationNoop {
  mutationId: string;
  reason: string;
}

/** Semantic AST operation */
export interface Mutation {
  mutationId: string;
  timestamp: number;
  moveElement?: MoveElement | undefined;
  updateText?: UpdateText | undefined;
  setInlineStyle?: SetInlineStyle | undefined;
  setAttribute?: SetAttribute | undefined;
  removeNode?: RemoveNode | undefined;
  insertElement?: InsertElement | undefined;
  setFrameBounds?: SetFrameBounds | undefined;
}

/** Set frame bounds (updates @frame doc comment) */
export interface SetFrameBounds {
  frameId: string;
  bounds?: Bounds | undefined;
}

/** Frame bounds */
export interface Bounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/** Move an element to a new parent at index */
export interface MoveElement {
  nodeId: string;
  newParentId: string;
  index: number;
}

/** Update text content (atomic replacement) */
export interface UpdateText {
  nodeId: string;
  content: string;
}

/** Set an inline style property */
export interface SetInlineStyle {
  nodeId: string;
  property: string;
  value: string;
}

/** Set an attribute value */
export interface SetAttribute {
  nodeId: string;
  name: string;
  value: string;
}

/** Remove a node from the tree */
export interface RemoveNode {
  nodeId: string;
}

/** Insert a new element (rare - most creation via templates) */
export interface InsertElement {
  parentId: string;
  index: number;
  /** Serialized AST element */
  elementJson: string;
}

/** Request document outline */
export interface OutlineRequest {
  filePath: string;
}

/** Document outline response */
export interface OutlineResponse {
  nodes: OutlineNode[];
  version: number;
}

/** Single node in document outline */
export interface OutlineNode {
  nodeId: string;
  type: NodeType;
  parentId?: string | undefined;
  childIds: string[];
  span?:
    | SourceSpan
    | undefined;
  /** e.g., component name, tag name */
  label?: string | undefined;
}

/** Source code location */
export interface SourceSpan {
  startLine: number;
  startCol: number;
  endLine: number;
  endCol: number;
}

/**
 * Bidirectional CRDT sync stream
 * Client sends updates, server broadcasts to other clients and sends VDOM patches
 */
export interface CrdtSyncRequest {
  clientId: string;
  filePath: string;
  /** Initial sync - join session and get current state */
  join?:
    | CrdtJoin
    | undefined;
  /** Send local CRDT update */
  update?:
    | CrdtUpdate
    | undefined;
  /** Acknowledge received update (for flow control) */
  ack?: CrdtAck | undefined;
}

/** Join a CRDT editing session */
export interface CrdtJoin {
  /** Client's current state vector (empty for new session) */
  stateVector: Uint8Array;
}

/** CRDT update (Yjs-compatible binary format) */
export interface CrdtUpdate {
  /** Delta update (encoded via Y.encodeStateAsUpdate) */
  update: Uint8Array;
  /** Client's state vector after this update */
  stateVector: Uint8Array;
  /** Origin of the change (for filtering) */
  origin: string;
}

/** Acknowledge receipt of an update */
export interface CrdtAck {
  sequence: number;
}

/** Server response in CRDT sync stream */
export interface CrdtSyncResponse {
  /** Welcome message with current document state */
  welcome?:
    | CrdtWelcome
    | undefined;
  /** Remote CRDT update from another client */
  remoteUpdate?:
    | CrdtUpdate
    | undefined;
  /** VDOM patch after successful parse */
  vdomPatch?:
    | CrdtVdomPatch
    | undefined;
  /** CSSOM update after successful parse */
  cssomPatch?:
    | CrdtCssomPatch
    | undefined;
  /** Parse error (document still synced, just invalid) */
  parseError?: CrdtParseError | undefined;
}

/** Welcome message when joining a session */
export interface CrdtWelcome {
  /** Full document state (for new clients) */
  documentState: Uint8Array;
  /** Current state vector */
  stateVector: Uint8Array;
  /** Current VDOM (if document is valid) */
  initialVdom?:
    | VDocPatch
    | undefined;
  /** Session info */
  version: number;
  clientCount: number;
}

/** VDOM patch from server after parse */
export interface CrdtVdomPatch {
  patches: VDocPatch[];
  version: number;
  /** Which client triggered this update (for origin filtering) */
  originClientId: string;
}

/** CSSOM update from server */
export interface CrdtCssomPatch {
  rules: CssRule[];
  version: number;
}

/** CSS rule for CSSOM */
export interface CssRule {
  selector: string;
  properties: { [key: string]: string };
}

export interface CssRule_PropertiesEntry {
  key: string;
  value: string;
}

/** Parse error (document synced but invalid) */
export interface CrdtParseError {
  error: string;
  line: number;
  column: number;
}

/** Request to stream buffer content directly (no file I/O) */
export interface BufferRequest {
  clientId: string;
  filePath: string;
  content: string;
  /** Version-based sync for reconnection handling */
  expectedStateVersion?: number | undefined;
}

/** Request to close preview and cleanup state */
export interface ClosePreviewRequest {
  clientId: string;
}

/** Response confirming state cleanup */
export interface ClosePreviewResponse {
  success: boolean;
  message?: string | undefined;
}

/** Heartbeat request for liveness tracking */
export interface HeartbeatRequest {
  clientId: string;
}

/** Heartbeat response */
export interface HeartbeatResponse {
  acknowledged: boolean;
  serverTime: number;
}

function createBasePreviewRequest(): PreviewRequest {
  return { rootPath: "" };
}

export const PreviewRequest = {
  encode(message: PreviewRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rootPath !== "") {
      writer.uint32(10).string(message.rootPath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreviewRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rootPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewRequest {
    return { rootPath: isSet(object.rootPath) ? globalThis.String(object.rootPath) : "" };
  },

  toJSON(message: PreviewRequest): unknown {
    const obj: any = {};
    if (message.rootPath !== "") {
      obj.rootPath = message.rootPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewRequest>, I>>(base?: I): PreviewRequest {
    return PreviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewRequest>, I>>(object: I): PreviewRequest {
    const message = createBasePreviewRequest();
    message.rootPath = object.rootPath ?? "";
    return message;
  },
};

function createBasePreviewUpdate(): PreviewUpdate {
  return {
    filePath: "",
    patches: [],
    error: undefined,
    timestamp: 0,
    version: 0,
    acknowledgedMutationIds: [],
    changedByClientId: undefined,
  };
}

export const PreviewUpdate = {
  encode(message: PreviewUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    for (const v of message.patches) {
      VDocPatch.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    if (message.version !== 0) {
      writer.uint32(40).uint64(message.version);
    }
    for (const v of message.acknowledgedMutationIds) {
      writer.uint32(50).string(v!);
    }
    if (message.changedByClientId !== undefined) {
      writer.uint32(58).string(message.changedByClientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PreviewUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreviewUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.patches.push(VDocPatch.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.acknowledgedMutationIds.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.changedByClientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreviewUpdate {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e: any) => VDocPatch.fromJSON(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      acknowledgedMutationIds: globalThis.Array.isArray(object?.acknowledgedMutationIds)
        ? object.acknowledgedMutationIds.map((e: any) => globalThis.String(e))
        : [],
      changedByClientId: isSet(object.changedByClientId) ? globalThis.String(object.changedByClientId) : undefined,
    };
  },

  toJSON(message: PreviewUpdate): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.patches?.length) {
      obj.patches = message.patches.map((e) => VDocPatch.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.acknowledgedMutationIds?.length) {
      obj.acknowledgedMutationIds = message.acknowledgedMutationIds;
    }
    if (message.changedByClientId !== undefined) {
      obj.changedByClientId = message.changedByClientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreviewUpdate>, I>>(base?: I): PreviewUpdate {
    return PreviewUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreviewUpdate>, I>>(object: I): PreviewUpdate {
    const message = createBasePreviewUpdate();
    message.filePath = object.filePath ?? "";
    message.patches = object.patches?.map((e) => VDocPatch.fromPartial(e)) || [];
    message.error = object.error ?? undefined;
    message.timestamp = object.timestamp ?? 0;
    message.version = object.version ?? 0;
    message.acknowledgedMutationIds = object.acknowledgedMutationIds?.map((e) => e) || [];
    message.changedByClientId = object.changedByClientId ?? undefined;
    return message;
  },
};

function createBaseWatchRequest(): WatchRequest {
  return { directory: "", patterns: [] };
}

export const WatchRequest = {
  encode(message: WatchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.directory !== "") {
      writer.uint32(10).string(message.directory);
    }
    for (const v of message.patterns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WatchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.directory = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.patterns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchRequest {
    return {
      directory: isSet(object.directory) ? globalThis.String(object.directory) : "",
      patterns: globalThis.Array.isArray(object?.patterns) ? object.patterns.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: WatchRequest): unknown {
    const obj: any = {};
    if (message.directory !== "") {
      obj.directory = message.directory;
    }
    if (message.patterns?.length) {
      obj.patterns = message.patterns;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchRequest>, I>>(base?: I): WatchRequest {
    return WatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchRequest>, I>>(object: I): WatchRequest {
    const message = createBaseWatchRequest();
    message.directory = object.directory ?? "";
    message.patterns = object.patterns?.map((e) => e) || [];
    return message;
  },
};

function createBaseFileEvent(): FileEvent {
  return { eventType: 0, filePath: "", timestamp: 0 };
}

export const FileEvent = {
  encode(message: FileEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== 0) {
      writer.uint32(8).int32(message.eventType);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FileEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.eventType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileEvent {
    return {
      eventType: isSet(object.eventType) ? fileEvent_EventTypeFromJSON(object.eventType) : 0,
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: FileEvent): unknown {
    const obj: any = {};
    if (message.eventType !== 0) {
      obj.eventType = fileEvent_EventTypeToJSON(message.eventType);
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileEvent>, I>>(base?: I): FileEvent {
    return FileEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileEvent>, I>>(object: I): FileEvent {
    const message = createBaseFileEvent();
    message.eventType = object.eventType ?? 0;
    message.filePath = object.filePath ?? "";
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseMutationRequest(): MutationRequest {
  return { clientId: "", filePath: "", mutation: undefined, expectedVersion: 0 };
}

export const MutationRequest = {
  encode(message: MutationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.mutation !== undefined) {
      Mutation.encode(message.mutation, writer.uint32(26).fork()).ldelim();
    }
    if (message.expectedVersion !== 0) {
      writer.uint32(32).uint64(message.expectedVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mutation = Mutation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expectedVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      mutation: isSet(object.mutation) ? Mutation.fromJSON(object.mutation) : undefined,
      expectedVersion: isSet(object.expectedVersion) ? globalThis.Number(object.expectedVersion) : 0,
    };
  },

  toJSON(message: MutationRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.mutation !== undefined) {
      obj.mutation = Mutation.toJSON(message.mutation);
    }
    if (message.expectedVersion !== 0) {
      obj.expectedVersion = Math.round(message.expectedVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationRequest>, I>>(base?: I): MutationRequest {
    return MutationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationRequest>, I>>(object: I): MutationRequest {
    const message = createBaseMutationRequest();
    message.clientId = object.clientId ?? "";
    message.filePath = object.filePath ?? "";
    message.mutation = (object.mutation !== undefined && object.mutation !== null)
      ? Mutation.fromPartial(object.mutation)
      : undefined;
    message.expectedVersion = object.expectedVersion ?? 0;
    return message;
  },
};

function createBaseMutationResponse(): MutationResponse {
  return { ack: undefined, rebased: undefined, noop: undefined };
}

export const MutationResponse = {
  encode(message: MutationResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ack !== undefined) {
      MutationAck.encode(message.ack, writer.uint32(10).fork()).ldelim();
    }
    if (message.rebased !== undefined) {
      MutationRebased.encode(message.rebased, writer.uint32(18).fork()).ldelim();
    }
    if (message.noop !== undefined) {
      MutationNoop.encode(message.noop, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ack = MutationAck.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rebased = MutationRebased.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noop = MutationNoop.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationResponse {
    return {
      ack: isSet(object.ack) ? MutationAck.fromJSON(object.ack) : undefined,
      rebased: isSet(object.rebased) ? MutationRebased.fromJSON(object.rebased) : undefined,
      noop: isSet(object.noop) ? MutationNoop.fromJSON(object.noop) : undefined,
    };
  },

  toJSON(message: MutationResponse): unknown {
    const obj: any = {};
    if (message.ack !== undefined) {
      obj.ack = MutationAck.toJSON(message.ack);
    }
    if (message.rebased !== undefined) {
      obj.rebased = MutationRebased.toJSON(message.rebased);
    }
    if (message.noop !== undefined) {
      obj.noop = MutationNoop.toJSON(message.noop);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationResponse>, I>>(base?: I): MutationResponse {
    return MutationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationResponse>, I>>(object: I): MutationResponse {
    const message = createBaseMutationResponse();
    message.ack = (object.ack !== undefined && object.ack !== null) ? MutationAck.fromPartial(object.ack) : undefined;
    message.rebased = (object.rebased !== undefined && object.rebased !== null)
      ? MutationRebased.fromPartial(object.rebased)
      : undefined;
    message.noop = (object.noop !== undefined && object.noop !== null)
      ? MutationNoop.fromPartial(object.noop)
      : undefined;
    return message;
  },
};

function createBaseMutationAck(): MutationAck {
  return { mutationId: "", newVersion: 0, timestamp: 0 };
}

export const MutationAck = {
  encode(message: MutationAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.newVersion !== 0) {
      writer.uint32(16).uint64(message.newVersion);
    }
    if (message.timestamp !== 0) {
      writer.uint32(24).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newVersion = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationAck {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
    };
  },

  toJSON(message: MutationAck): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.newVersion !== 0) {
      obj.newVersion = Math.round(message.newVersion);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationAck>, I>>(base?: I): MutationAck {
    return MutationAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationAck>, I>>(object: I): MutationAck {
    const message = createBaseMutationAck();
    message.mutationId = object.mutationId ?? "";
    message.newVersion = object.newVersion ?? 0;
    message.timestamp = object.timestamp ?? 0;
    return message;
  },
};

function createBaseMutationRebased(): MutationRebased {
  return { originalMutationId: "", transformedMutation: undefined, newVersion: 0, reason: "" };
}

export const MutationRebased = {
  encode(message: MutationRebased, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originalMutationId !== "") {
      writer.uint32(10).string(message.originalMutationId);
    }
    if (message.transformedMutation !== undefined) {
      Mutation.encode(message.transformedMutation, writer.uint32(18).fork()).ldelim();
    }
    if (message.newVersion !== 0) {
      writer.uint32(24).uint64(message.newVersion);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationRebased {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationRebased();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalMutationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transformedMutation = Mutation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.newVersion = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationRebased {
    return {
      originalMutationId: isSet(object.originalMutationId) ? globalThis.String(object.originalMutationId) : "",
      transformedMutation: isSet(object.transformedMutation)
        ? Mutation.fromJSON(object.transformedMutation)
        : undefined,
      newVersion: isSet(object.newVersion) ? globalThis.Number(object.newVersion) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MutationRebased): unknown {
    const obj: any = {};
    if (message.originalMutationId !== "") {
      obj.originalMutationId = message.originalMutationId;
    }
    if (message.transformedMutation !== undefined) {
      obj.transformedMutation = Mutation.toJSON(message.transformedMutation);
    }
    if (message.newVersion !== 0) {
      obj.newVersion = Math.round(message.newVersion);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationRebased>, I>>(base?: I): MutationRebased {
    return MutationRebased.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationRebased>, I>>(object: I): MutationRebased {
    const message = createBaseMutationRebased();
    message.originalMutationId = object.originalMutationId ?? "";
    message.transformedMutation = (object.transformedMutation !== undefined && object.transformedMutation !== null)
      ? Mutation.fromPartial(object.transformedMutation)
      : undefined;
    message.newVersion = object.newVersion ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMutationNoop(): MutationNoop {
  return { mutationId: "", reason: "" };
}

export const MutationNoop = {
  encode(message: MutationNoop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MutationNoop {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutationNoop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MutationNoop {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MutationNoop): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MutationNoop>, I>>(base?: I): MutationNoop {
    return MutationNoop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MutationNoop>, I>>(object: I): MutationNoop {
    const message = createBaseMutationNoop();
    message.mutationId = object.mutationId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMutation(): Mutation {
  return {
    mutationId: "",
    timestamp: 0,
    moveElement: undefined,
    updateText: undefined,
    setInlineStyle: undefined,
    setAttribute: undefined,
    removeNode: undefined,
    insertElement: undefined,
    setFrameBounds: undefined,
  };
}

export const Mutation = {
  encode(message: Mutation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mutationId !== "") {
      writer.uint32(10).string(message.mutationId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.moveElement !== undefined) {
      MoveElement.encode(message.moveElement, writer.uint32(26).fork()).ldelim();
    }
    if (message.updateText !== undefined) {
      UpdateText.encode(message.updateText, writer.uint32(34).fork()).ldelim();
    }
    if (message.setInlineStyle !== undefined) {
      SetInlineStyle.encode(message.setInlineStyle, writer.uint32(42).fork()).ldelim();
    }
    if (message.setAttribute !== undefined) {
      SetAttribute.encode(message.setAttribute, writer.uint32(50).fork()).ldelim();
    }
    if (message.removeNode !== undefined) {
      RemoveNode.encode(message.removeNode, writer.uint32(58).fork()).ldelim();
    }
    if (message.insertElement !== undefined) {
      InsertElement.encode(message.insertElement, writer.uint32(66).fork()).ldelim();
    }
    if (message.setFrameBounds !== undefined) {
      SetFrameBounds.encode(message.setFrameBounds, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Mutation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mutationId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.moveElement = MoveElement.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateText = UpdateText.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.setInlineStyle = SetInlineStyle.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.setAttribute = SetAttribute.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.removeNode = RemoveNode.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.insertElement = InsertElement.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.setFrameBounds = SetFrameBounds.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mutation {
    return {
      mutationId: isSet(object.mutationId) ? globalThis.String(object.mutationId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      moveElement: isSet(object.moveElement) ? MoveElement.fromJSON(object.moveElement) : undefined,
      updateText: isSet(object.updateText) ? UpdateText.fromJSON(object.updateText) : undefined,
      setInlineStyle: isSet(object.setInlineStyle) ? SetInlineStyle.fromJSON(object.setInlineStyle) : undefined,
      setAttribute: isSet(object.setAttribute) ? SetAttribute.fromJSON(object.setAttribute) : undefined,
      removeNode: isSet(object.removeNode) ? RemoveNode.fromJSON(object.removeNode) : undefined,
      insertElement: isSet(object.insertElement) ? InsertElement.fromJSON(object.insertElement) : undefined,
      setFrameBounds: isSet(object.setFrameBounds) ? SetFrameBounds.fromJSON(object.setFrameBounds) : undefined,
    };
  },

  toJSON(message: Mutation): unknown {
    const obj: any = {};
    if (message.mutationId !== "") {
      obj.mutationId = message.mutationId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.moveElement !== undefined) {
      obj.moveElement = MoveElement.toJSON(message.moveElement);
    }
    if (message.updateText !== undefined) {
      obj.updateText = UpdateText.toJSON(message.updateText);
    }
    if (message.setInlineStyle !== undefined) {
      obj.setInlineStyle = SetInlineStyle.toJSON(message.setInlineStyle);
    }
    if (message.setAttribute !== undefined) {
      obj.setAttribute = SetAttribute.toJSON(message.setAttribute);
    }
    if (message.removeNode !== undefined) {
      obj.removeNode = RemoveNode.toJSON(message.removeNode);
    }
    if (message.insertElement !== undefined) {
      obj.insertElement = InsertElement.toJSON(message.insertElement);
    }
    if (message.setFrameBounds !== undefined) {
      obj.setFrameBounds = SetFrameBounds.toJSON(message.setFrameBounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mutation>, I>>(base?: I): Mutation {
    return Mutation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mutation>, I>>(object: I): Mutation {
    const message = createBaseMutation();
    message.mutationId = object.mutationId ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.moveElement = (object.moveElement !== undefined && object.moveElement !== null)
      ? MoveElement.fromPartial(object.moveElement)
      : undefined;
    message.updateText = (object.updateText !== undefined && object.updateText !== null)
      ? UpdateText.fromPartial(object.updateText)
      : undefined;
    message.setInlineStyle = (object.setInlineStyle !== undefined && object.setInlineStyle !== null)
      ? SetInlineStyle.fromPartial(object.setInlineStyle)
      : undefined;
    message.setAttribute = (object.setAttribute !== undefined && object.setAttribute !== null)
      ? SetAttribute.fromPartial(object.setAttribute)
      : undefined;
    message.removeNode = (object.removeNode !== undefined && object.removeNode !== null)
      ? RemoveNode.fromPartial(object.removeNode)
      : undefined;
    message.insertElement = (object.insertElement !== undefined && object.insertElement !== null)
      ? InsertElement.fromPartial(object.insertElement)
      : undefined;
    message.setFrameBounds = (object.setFrameBounds !== undefined && object.setFrameBounds !== null)
      ? SetFrameBounds.fromPartial(object.setFrameBounds)
      : undefined;
    return message;
  },
};

function createBaseSetFrameBounds(): SetFrameBounds {
  return { frameId: "", bounds: undefined };
}

export const SetFrameBounds = {
  encode(message: SetFrameBounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameId !== "") {
      writer.uint32(10).string(message.frameId);
    }
    if (message.bounds !== undefined) {
      Bounds.encode(message.bounds, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetFrameBounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetFrameBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frameId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bounds = Bounds.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetFrameBounds {
    return {
      frameId: isSet(object.frameId) ? globalThis.String(object.frameId) : "",
      bounds: isSet(object.bounds) ? Bounds.fromJSON(object.bounds) : undefined,
    };
  },

  toJSON(message: SetFrameBounds): unknown {
    const obj: any = {};
    if (message.frameId !== "") {
      obj.frameId = message.frameId;
    }
    if (message.bounds !== undefined) {
      obj.bounds = Bounds.toJSON(message.bounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetFrameBounds>, I>>(base?: I): SetFrameBounds {
    return SetFrameBounds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetFrameBounds>, I>>(object: I): SetFrameBounds {
    const message = createBaseSetFrameBounds();
    message.frameId = object.frameId ?? "";
    message.bounds = (object.bounds !== undefined && object.bounds !== null)
      ? Bounds.fromPartial(object.bounds)
      : undefined;
    return message;
  },
};

function createBaseBounds(): Bounds {
  return { x: 0, y: 0, width: 0, height: 0 };
}

export const Bounds = {
  encode(message: Bounds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.width !== 0) {
      writer.uint32(29).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(37).float(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Bounds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.width = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bounds {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: Bounds): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bounds>, I>>(base?: I): Bounds {
    return Bounds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bounds>, I>>(object: I): Bounds {
    const message = createBaseBounds();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseMoveElement(): MoveElement {
  return { nodeId: "", newParentId: "", index: 0 };
}

export const MoveElement = {
  encode(message: MoveElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.newParentId !== "") {
      writer.uint32(18).string(message.newParentId);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoveElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newParentId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveElement {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      newParentId: isSet(object.newParentId) ? globalThis.String(object.newParentId) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: MoveElement): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.newParentId !== "") {
      obj.newParentId = message.newParentId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoveElement>, I>>(base?: I): MoveElement {
    return MoveElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoveElement>, I>>(object: I): MoveElement {
    const message = createBaseMoveElement();
    message.nodeId = object.nodeId ?? "";
    message.newParentId = object.newParentId ?? "";
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseUpdateText(): UpdateText {
  return { nodeId: "", content: "" };
}

export const UpdateText = {
  encode(message: UpdateText, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateText {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateText {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: UpdateText): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateText>, I>>(base?: I): UpdateText {
    return UpdateText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateText>, I>>(object: I): UpdateText {
    const message = createBaseUpdateText();
    message.nodeId = object.nodeId ?? "";
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseSetInlineStyle(): SetInlineStyle {
  return { nodeId: "", property: "", value: "" };
}

export const SetInlineStyle = {
  encode(message: SetInlineStyle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.property !== "") {
      writer.uint32(18).string(message.property);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetInlineStyle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetInlineStyle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.property = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetInlineStyle {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetInlineStyle): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetInlineStyle>, I>>(base?: I): SetInlineStyle {
    return SetInlineStyle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetInlineStyle>, I>>(object: I): SetInlineStyle {
    const message = createBaseSetInlineStyle();
    message.nodeId = object.nodeId ?? "";
    message.property = object.property ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSetAttribute(): SetAttribute {
  return { nodeId: "", name: "", value: "" };
}

export const SetAttribute = {
  encode(message: SetAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SetAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetAttribute {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SetAttribute): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SetAttribute>, I>>(base?: I): SetAttribute {
    return SetAttribute.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SetAttribute>, I>>(object: I): SetAttribute {
    const message = createBaseSetAttribute();
    message.nodeId = object.nodeId ?? "";
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRemoveNode(): RemoveNode {
  return { nodeId: "" };
}

export const RemoveNode = {
  encode(message: RemoveNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveNode {
    return { nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "" };
  },

  toJSON(message: RemoveNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveNode>, I>>(base?: I): RemoveNode {
    return RemoveNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveNode>, I>>(object: I): RemoveNode {
    const message = createBaseRemoveNode();
    message.nodeId = object.nodeId ?? "";
    return message;
  },
};

function createBaseInsertElement(): InsertElement {
  return { parentId: "", index: 0, elementJson: "" };
}

export const InsertElement = {
  encode(message: InsertElement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.parentId !== "") {
      writer.uint32(10).string(message.parentId);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    if (message.elementJson !== "") {
      writer.uint32(26).string(message.elementJson);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InsertElement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.elementJson = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertElement {
    return {
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      elementJson: isSet(object.elementJson) ? globalThis.String(object.elementJson) : "",
    };
  },

  toJSON(message: InsertElement): unknown {
    const obj: any = {};
    if (message.parentId !== "") {
      obj.parentId = message.parentId;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.elementJson !== "") {
      obj.elementJson = message.elementJson;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InsertElement>, I>>(base?: I): InsertElement {
    return InsertElement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InsertElement>, I>>(object: I): InsertElement {
    const message = createBaseInsertElement();
    message.parentId = object.parentId ?? "";
    message.index = object.index ?? 0;
    message.elementJson = object.elementJson ?? "";
    return message;
  },
};

function createBaseOutlineRequest(): OutlineRequest {
  return { filePath: "" };
}

export const OutlineRequest = {
  encode(message: OutlineRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineRequest {
    return { filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "" };
  },

  toJSON(message: OutlineRequest): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineRequest>, I>>(base?: I): OutlineRequest {
    return OutlineRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineRequest>, I>>(object: I): OutlineRequest {
    const message = createBaseOutlineRequest();
    message.filePath = object.filePath ?? "";
    return message;
  },
};

function createBaseOutlineResponse(): OutlineResponse {
  return { nodes: [], version: 0 };
}

export const OutlineResponse = {
  encode(message: OutlineResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nodes) {
      OutlineNode.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(16).uint64(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(OutlineNode.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => OutlineNode.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: OutlineResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => OutlineNode.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineResponse>, I>>(base?: I): OutlineResponse {
    return OutlineResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineResponse>, I>>(object: I): OutlineResponse {
    const message = createBaseOutlineResponse();
    message.nodes = object.nodes?.map((e) => OutlineNode.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseOutlineNode(): OutlineNode {
  return { nodeId: "", type: 0, parentId: undefined, childIds: [], span: undefined, label: undefined };
}

export const OutlineNode = {
  encode(message: OutlineNode, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.parentId !== undefined) {
      writer.uint32(26).string(message.parentId);
    }
    for (const v of message.childIds) {
      writer.uint32(34).string(v!);
    }
    if (message.span !== undefined) {
      SourceSpan.encode(message.span, writer.uint32(42).fork()).ldelim();
    }
    if (message.label !== undefined) {
      writer.uint32(50).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OutlineNode {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutlineNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.childIds.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.span = SourceSpan.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutlineNode {
    return {
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      type: isSet(object.type) ? nodeTypeFromJSON(object.type) : 0,
      parentId: isSet(object.parentId) ? globalThis.String(object.parentId) : undefined,
      childIds: globalThis.Array.isArray(object?.childIds) ? object.childIds.map((e: any) => globalThis.String(e)) : [],
      span: isSet(object.span) ? SourceSpan.fromJSON(object.span) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
    };
  },

  toJSON(message: OutlineNode): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.type !== 0) {
      obj.type = nodeTypeToJSON(message.type);
    }
    if (message.parentId !== undefined) {
      obj.parentId = message.parentId;
    }
    if (message.childIds?.length) {
      obj.childIds = message.childIds;
    }
    if (message.span !== undefined) {
      obj.span = SourceSpan.toJSON(message.span);
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutlineNode>, I>>(base?: I): OutlineNode {
    return OutlineNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutlineNode>, I>>(object: I): OutlineNode {
    const message = createBaseOutlineNode();
    message.nodeId = object.nodeId ?? "";
    message.type = object.type ?? 0;
    message.parentId = object.parentId ?? undefined;
    message.childIds = object.childIds?.map((e) => e) || [];
    message.span = (object.span !== undefined && object.span !== null)
      ? SourceSpan.fromPartial(object.span)
      : undefined;
    message.label = object.label ?? undefined;
    return message;
  },
};

function createBaseSourceSpan(): SourceSpan {
  return { startLine: 0, startCol: 0, endLine: 0, endCol: 0 };
}

export const SourceSpan = {
  encode(message: SourceSpan, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.startLine !== 0) {
      writer.uint32(8).uint32(message.startLine);
    }
    if (message.startCol !== 0) {
      writer.uint32(16).uint32(message.startCol);
    }
    if (message.endLine !== 0) {
      writer.uint32(24).uint32(message.endLine);
    }
    if (message.endCol !== 0) {
      writer.uint32(32).uint32(message.endCol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceSpan {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startLine = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.startCol = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.endLine = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.endCol = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceSpan {
    return {
      startLine: isSet(object.startLine) ? globalThis.Number(object.startLine) : 0,
      startCol: isSet(object.startCol) ? globalThis.Number(object.startCol) : 0,
      endLine: isSet(object.endLine) ? globalThis.Number(object.endLine) : 0,
      endCol: isSet(object.endCol) ? globalThis.Number(object.endCol) : 0,
    };
  },

  toJSON(message: SourceSpan): unknown {
    const obj: any = {};
    if (message.startLine !== 0) {
      obj.startLine = Math.round(message.startLine);
    }
    if (message.startCol !== 0) {
      obj.startCol = Math.round(message.startCol);
    }
    if (message.endLine !== 0) {
      obj.endLine = Math.round(message.endLine);
    }
    if (message.endCol !== 0) {
      obj.endCol = Math.round(message.endCol);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SourceSpan>, I>>(base?: I): SourceSpan {
    return SourceSpan.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SourceSpan>, I>>(object: I): SourceSpan {
    const message = createBaseSourceSpan();
    message.startLine = object.startLine ?? 0;
    message.startCol = object.startCol ?? 0;
    message.endLine = object.endLine ?? 0;
    message.endCol = object.endCol ?? 0;
    return message;
  },
};

function createBaseCrdtSyncRequest(): CrdtSyncRequest {
  return { clientId: "", filePath: "", join: undefined, update: undefined, ack: undefined };
}

export const CrdtSyncRequest = {
  encode(message: CrdtSyncRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.join !== undefined) {
      CrdtJoin.encode(message.join, writer.uint32(26).fork()).ldelim();
    }
    if (message.update !== undefined) {
      CrdtUpdate.encode(message.update, writer.uint32(34).fork()).ldelim();
    }
    if (message.ack !== undefined) {
      CrdtAck.encode(message.ack, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtSyncRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.join = CrdtJoin.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.update = CrdtUpdate.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ack = CrdtAck.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtSyncRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      join: isSet(object.join) ? CrdtJoin.fromJSON(object.join) : undefined,
      update: isSet(object.update) ? CrdtUpdate.fromJSON(object.update) : undefined,
      ack: isSet(object.ack) ? CrdtAck.fromJSON(object.ack) : undefined,
    };
  },

  toJSON(message: CrdtSyncRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.join !== undefined) {
      obj.join = CrdtJoin.toJSON(message.join);
    }
    if (message.update !== undefined) {
      obj.update = CrdtUpdate.toJSON(message.update);
    }
    if (message.ack !== undefined) {
      obj.ack = CrdtAck.toJSON(message.ack);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtSyncRequest>, I>>(base?: I): CrdtSyncRequest {
    return CrdtSyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtSyncRequest>, I>>(object: I): CrdtSyncRequest {
    const message = createBaseCrdtSyncRequest();
    message.clientId = object.clientId ?? "";
    message.filePath = object.filePath ?? "";
    message.join = (object.join !== undefined && object.join !== null) ? CrdtJoin.fromPartial(object.join) : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? CrdtUpdate.fromPartial(object.update)
      : undefined;
    message.ack = (object.ack !== undefined && object.ack !== null) ? CrdtAck.fromPartial(object.ack) : undefined;
    return message;
  },
};

function createBaseCrdtJoin(): CrdtJoin {
  return { stateVector: new Uint8Array(0) };
}

export const CrdtJoin = {
  encode(message: CrdtJoin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stateVector.length !== 0) {
      writer.uint32(10).bytes(message.stateVector);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtJoin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stateVector = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtJoin {
    return { stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0) };
  },

  toJSON(message: CrdtJoin): unknown {
    const obj: any = {};
    if (message.stateVector.length !== 0) {
      obj.stateVector = base64FromBytes(message.stateVector);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtJoin>, I>>(base?: I): CrdtJoin {
    return CrdtJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtJoin>, I>>(object: I): CrdtJoin {
    const message = createBaseCrdtJoin();
    message.stateVector = object.stateVector ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCrdtUpdate(): CrdtUpdate {
  return { update: new Uint8Array(0), stateVector: new Uint8Array(0), origin: "" };
}

export const CrdtUpdate = {
  encode(message: CrdtUpdate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.update.length !== 0) {
      writer.uint32(10).bytes(message.update);
    }
    if (message.stateVector.length !== 0) {
      writer.uint32(18).bytes(message.stateVector);
    }
    if (message.origin !== "") {
      writer.uint32(26).string(message.origin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtUpdate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.update = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateVector = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.origin = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtUpdate {
    return {
      update: isSet(object.update) ? bytesFromBase64(object.update) : new Uint8Array(0),
      stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0),
      origin: isSet(object.origin) ? globalThis.String(object.origin) : "",
    };
  },

  toJSON(message: CrdtUpdate): unknown {
    const obj: any = {};
    if (message.update.length !== 0) {
      obj.update = base64FromBytes(message.update);
    }
    if (message.stateVector.length !== 0) {
      obj.stateVector = base64FromBytes(message.stateVector);
    }
    if (message.origin !== "") {
      obj.origin = message.origin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtUpdate>, I>>(base?: I): CrdtUpdate {
    return CrdtUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtUpdate>, I>>(object: I): CrdtUpdate {
    const message = createBaseCrdtUpdate();
    message.update = object.update ?? new Uint8Array(0);
    message.stateVector = object.stateVector ?? new Uint8Array(0);
    message.origin = object.origin ?? "";
    return message;
  },
};

function createBaseCrdtAck(): CrdtAck {
  return { sequence: 0 };
}

export const CrdtAck = {
  encode(message: CrdtAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sequence !== 0) {
      writer.uint32(8).uint64(message.sequence);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtAck {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sequence = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtAck {
    return { sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0 };
  },

  toJSON(message: CrdtAck): unknown {
    const obj: any = {};
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtAck>, I>>(base?: I): CrdtAck {
    return CrdtAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtAck>, I>>(object: I): CrdtAck {
    const message = createBaseCrdtAck();
    message.sequence = object.sequence ?? 0;
    return message;
  },
};

function createBaseCrdtSyncResponse(): CrdtSyncResponse {
  return {
    welcome: undefined,
    remoteUpdate: undefined,
    vdomPatch: undefined,
    cssomPatch: undefined,
    parseError: undefined,
  };
}

export const CrdtSyncResponse = {
  encode(message: CrdtSyncResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.welcome !== undefined) {
      CrdtWelcome.encode(message.welcome, writer.uint32(10).fork()).ldelim();
    }
    if (message.remoteUpdate !== undefined) {
      CrdtUpdate.encode(message.remoteUpdate, writer.uint32(18).fork()).ldelim();
    }
    if (message.vdomPatch !== undefined) {
      CrdtVdomPatch.encode(message.vdomPatch, writer.uint32(26).fork()).ldelim();
    }
    if (message.cssomPatch !== undefined) {
      CrdtCssomPatch.encode(message.cssomPatch, writer.uint32(34).fork()).ldelim();
    }
    if (message.parseError !== undefined) {
      CrdtParseError.encode(message.parseError, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtSyncResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.welcome = CrdtWelcome.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remoteUpdate = CrdtUpdate.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vdomPatch = CrdtVdomPatch.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cssomPatch = CrdtCssomPatch.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parseError = CrdtParseError.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtSyncResponse {
    return {
      welcome: isSet(object.welcome) ? CrdtWelcome.fromJSON(object.welcome) : undefined,
      remoteUpdate: isSet(object.remoteUpdate) ? CrdtUpdate.fromJSON(object.remoteUpdate) : undefined,
      vdomPatch: isSet(object.vdomPatch) ? CrdtVdomPatch.fromJSON(object.vdomPatch) : undefined,
      cssomPatch: isSet(object.cssomPatch) ? CrdtCssomPatch.fromJSON(object.cssomPatch) : undefined,
      parseError: isSet(object.parseError) ? CrdtParseError.fromJSON(object.parseError) : undefined,
    };
  },

  toJSON(message: CrdtSyncResponse): unknown {
    const obj: any = {};
    if (message.welcome !== undefined) {
      obj.welcome = CrdtWelcome.toJSON(message.welcome);
    }
    if (message.remoteUpdate !== undefined) {
      obj.remoteUpdate = CrdtUpdate.toJSON(message.remoteUpdate);
    }
    if (message.vdomPatch !== undefined) {
      obj.vdomPatch = CrdtVdomPatch.toJSON(message.vdomPatch);
    }
    if (message.cssomPatch !== undefined) {
      obj.cssomPatch = CrdtCssomPatch.toJSON(message.cssomPatch);
    }
    if (message.parseError !== undefined) {
      obj.parseError = CrdtParseError.toJSON(message.parseError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtSyncResponse>, I>>(base?: I): CrdtSyncResponse {
    return CrdtSyncResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtSyncResponse>, I>>(object: I): CrdtSyncResponse {
    const message = createBaseCrdtSyncResponse();
    message.welcome = (object.welcome !== undefined && object.welcome !== null)
      ? CrdtWelcome.fromPartial(object.welcome)
      : undefined;
    message.remoteUpdate = (object.remoteUpdate !== undefined && object.remoteUpdate !== null)
      ? CrdtUpdate.fromPartial(object.remoteUpdate)
      : undefined;
    message.vdomPatch = (object.vdomPatch !== undefined && object.vdomPatch !== null)
      ? CrdtVdomPatch.fromPartial(object.vdomPatch)
      : undefined;
    message.cssomPatch = (object.cssomPatch !== undefined && object.cssomPatch !== null)
      ? CrdtCssomPatch.fromPartial(object.cssomPatch)
      : undefined;
    message.parseError = (object.parseError !== undefined && object.parseError !== null)
      ? CrdtParseError.fromPartial(object.parseError)
      : undefined;
    return message;
  },
};

function createBaseCrdtWelcome(): CrdtWelcome {
  return {
    documentState: new Uint8Array(0),
    stateVector: new Uint8Array(0),
    initialVdom: undefined,
    version: 0,
    clientCount: 0,
  };
}

export const CrdtWelcome = {
  encode(message: CrdtWelcome, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.documentState.length !== 0) {
      writer.uint32(10).bytes(message.documentState);
    }
    if (message.stateVector.length !== 0) {
      writer.uint32(18).bytes(message.stateVector);
    }
    if (message.initialVdom !== undefined) {
      VDocPatch.encode(message.initialVdom, writer.uint32(26).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(32).uint64(message.version);
    }
    if (message.clientCount !== 0) {
      writer.uint32(40).uint32(message.clientCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtWelcome {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtWelcome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documentState = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateVector = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.initialVdom = VDocPatch.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clientCount = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtWelcome {
    return {
      documentState: isSet(object.documentState) ? bytesFromBase64(object.documentState) : new Uint8Array(0),
      stateVector: isSet(object.stateVector) ? bytesFromBase64(object.stateVector) : new Uint8Array(0),
      initialVdom: isSet(object.initialVdom) ? VDocPatch.fromJSON(object.initialVdom) : undefined,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      clientCount: isSet(object.clientCount) ? globalThis.Number(object.clientCount) : 0,
    };
  },

  toJSON(message: CrdtWelcome): unknown {
    const obj: any = {};
    if (message.documentState.length !== 0) {
      obj.documentState = base64FromBytes(message.documentState);
    }
    if (message.stateVector.length !== 0) {
      obj.stateVector = base64FromBytes(message.stateVector);
    }
    if (message.initialVdom !== undefined) {
      obj.initialVdom = VDocPatch.toJSON(message.initialVdom);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.clientCount !== 0) {
      obj.clientCount = Math.round(message.clientCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtWelcome>, I>>(base?: I): CrdtWelcome {
    return CrdtWelcome.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtWelcome>, I>>(object: I): CrdtWelcome {
    const message = createBaseCrdtWelcome();
    message.documentState = object.documentState ?? new Uint8Array(0);
    message.stateVector = object.stateVector ?? new Uint8Array(0);
    message.initialVdom = (object.initialVdom !== undefined && object.initialVdom !== null)
      ? VDocPatch.fromPartial(object.initialVdom)
      : undefined;
    message.version = object.version ?? 0;
    message.clientCount = object.clientCount ?? 0;
    return message;
  },
};

function createBaseCrdtVdomPatch(): CrdtVdomPatch {
  return { patches: [], version: 0, originClientId: "" };
}

export const CrdtVdomPatch = {
  encode(message: CrdtVdomPatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.patches) {
      VDocPatch.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(16).uint64(message.version);
    }
    if (message.originClientId !== "") {
      writer.uint32(26).string(message.originClientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtVdomPatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtVdomPatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patches.push(VDocPatch.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.originClientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtVdomPatch {
    return {
      patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e: any) => VDocPatch.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      originClientId: isSet(object.originClientId) ? globalThis.String(object.originClientId) : "",
    };
  },

  toJSON(message: CrdtVdomPatch): unknown {
    const obj: any = {};
    if (message.patches?.length) {
      obj.patches = message.patches.map((e) => VDocPatch.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.originClientId !== "") {
      obj.originClientId = message.originClientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtVdomPatch>, I>>(base?: I): CrdtVdomPatch {
    return CrdtVdomPatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtVdomPatch>, I>>(object: I): CrdtVdomPatch {
    const message = createBaseCrdtVdomPatch();
    message.patches = object.patches?.map((e) => VDocPatch.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    message.originClientId = object.originClientId ?? "";
    return message;
  },
};

function createBaseCrdtCssomPatch(): CrdtCssomPatch {
  return { rules: [], version: 0 };
}

export const CrdtCssomPatch = {
  encode(message: CrdtCssomPatch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.rules) {
      CssRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.version !== 0) {
      writer.uint32(16).uint64(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtCssomPatch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtCssomPatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(CssRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtCssomPatch {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => CssRule.fromJSON(e)) : [],
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
    };
  },

  toJSON(message: CrdtCssomPatch): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => CssRule.toJSON(e));
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtCssomPatch>, I>>(base?: I): CrdtCssomPatch {
    return CrdtCssomPatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtCssomPatch>, I>>(object: I): CrdtCssomPatch {
    const message = createBaseCrdtCssomPatch();
    message.rules = object.rules?.map((e) => CssRule.fromPartial(e)) || [];
    message.version = object.version ?? 0;
    return message;
  },
};

function createBaseCssRule(): CssRule {
  return { selector: "", properties: {} };
}

export const CssRule = {
  encode(message: CssRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.selector !== "") {
      writer.uint32(10).string(message.selector);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      CssRule_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CssRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCssRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.selector = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = CssRule_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CssRule {
    return {
      selector: isSet(object.selector) ? globalThis.String(object.selector) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CssRule): unknown {
    const obj: any = {};
    if (message.selector !== "") {
      obj.selector = message.selector;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CssRule>, I>>(base?: I): CssRule {
    return CssRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CssRule>, I>>(object: I): CssRule {
    const message = createBaseCssRule();
    message.selector = object.selector ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseCssRule_PropertiesEntry(): CssRule_PropertiesEntry {
  return { key: "", value: "" };
}

export const CssRule_PropertiesEntry = {
  encode(message: CssRule_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CssRule_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCssRule_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CssRule_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CssRule_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CssRule_PropertiesEntry>, I>>(base?: I): CssRule_PropertiesEntry {
    return CssRule_PropertiesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CssRule_PropertiesEntry>, I>>(object: I): CssRule_PropertiesEntry {
    const message = createBaseCssRule_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCrdtParseError(): CrdtParseError {
  return { error: "", line: 0, column: 0 };
}

export const CrdtParseError = {
  encode(message: CrdtParseError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.line !== 0) {
      writer.uint32(16).uint32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(24).uint32(message.column);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CrdtParseError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCrdtParseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.line = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.column = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CrdtParseError {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
    };
  },

  toJSON(message: CrdtParseError): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CrdtParseError>, I>>(base?: I): CrdtParseError {
    return CrdtParseError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CrdtParseError>, I>>(object: I): CrdtParseError {
    const message = createBaseCrdtParseError();
    message.error = object.error ?? "";
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

function createBaseBufferRequest(): BufferRequest {
  return { clientId: "", filePath: "", content: "", expectedStateVersion: undefined };
}

export const BufferRequest = {
  encode(message: BufferRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.filePath !== "") {
      writer.uint32(18).string(message.filePath);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.expectedStateVersion !== undefined) {
      writer.uint32(32).uint64(message.expectedStateVersion);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BufferRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBufferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filePath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.expectedStateVersion = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BufferRequest {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      expectedStateVersion: isSet(object.expectedStateVersion)
        ? globalThis.Number(object.expectedStateVersion)
        : undefined,
    };
  },

  toJSON(message: BufferRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.expectedStateVersion !== undefined) {
      obj.expectedStateVersion = Math.round(message.expectedStateVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BufferRequest>, I>>(base?: I): BufferRequest {
    return BufferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BufferRequest>, I>>(object: I): BufferRequest {
    const message = createBaseBufferRequest();
    message.clientId = object.clientId ?? "";
    message.filePath = object.filePath ?? "";
    message.content = object.content ?? "";
    message.expectedStateVersion = object.expectedStateVersion ?? undefined;
    return message;
  },
};

function createBaseClosePreviewRequest(): ClosePreviewRequest {
  return { clientId: "" };
}

export const ClosePreviewRequest = {
  encode(message: ClosePreviewRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClosePreviewRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosePreviewRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosePreviewRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: ClosePreviewRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosePreviewRequest>, I>>(base?: I): ClosePreviewRequest {
    return ClosePreviewRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosePreviewRequest>, I>>(object: I): ClosePreviewRequest {
    const message = createBaseClosePreviewRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseClosePreviewResponse(): ClosePreviewResponse {
  return { success: false, message: undefined };
}

export const ClosePreviewResponse = {
  encode(message: ClosePreviewResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClosePreviewResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClosePreviewResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClosePreviewResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: ClosePreviewResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClosePreviewResponse>, I>>(base?: I): ClosePreviewResponse {
    return ClosePreviewResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClosePreviewResponse>, I>>(object: I): ClosePreviewResponse {
    const message = createBaseClosePreviewResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseHeartbeatRequest(): HeartbeatRequest {
  return { clientId: "" };
}

export const HeartbeatRequest = {
  encode(message: HeartbeatRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatRequest {
    return { clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "" };
  },

  toJSON(message: HeartbeatRequest): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(base?: I): HeartbeatRequest {
    return HeartbeatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatRequest>, I>>(object: I): HeartbeatRequest {
    const message = createBaseHeartbeatRequest();
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseHeartbeatResponse(): HeartbeatResponse {
  return { acknowledged: false, serverTime: 0 };
}

export const HeartbeatResponse = {
  encode(message: HeartbeatResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.acknowledged !== false) {
      writer.uint32(8).bool(message.acknowledged);
    }
    if (message.serverTime !== 0) {
      writer.uint32(16).uint64(message.serverTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HeartbeatResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHeartbeatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.serverTime = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HeartbeatResponse {
    return {
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
      serverTime: isSet(object.serverTime) ? globalThis.Number(object.serverTime) : 0,
    };
  },

  toJSON(message: HeartbeatResponse): unknown {
    const obj: any = {};
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    if (message.serverTime !== 0) {
      obj.serverTime = Math.round(message.serverTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(base?: I): HeartbeatResponse {
    return HeartbeatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HeartbeatResponse>, I>>(object: I): HeartbeatResponse {
    const message = createBaseHeartbeatResponse();
    message.acknowledged = object.acknowledged ?? false;
    message.serverTime = object.serverTime ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
